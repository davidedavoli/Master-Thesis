%!TeX spellcheck = en-US
% \newtheorem{defn}{Definition}
% \newtheorem{conj}{Conjecture}
% \newtheorem{remark}{Remark}
% \newtheorem{notation}{Notation}
% \newtheorem{prop}{Proposition}
% \newtheorem{ex}{Example}
% \newtheorem{lemma}{Lemma}
% \newtheorem{cor}{Corollary}
% \newtheorem{theorem}{Theorem}
%
%
% \newcommand{\longrightarrow}{\longrightarrow}
%
%
%
%
%
%
%
%
%
% \newcommand{\PPT}{\mathcal{PPT}}
% \newcommand{\SFP}{\mathcal{SFP}}
%
% \newcommand{\POR}{\mathcal{POR}}
% \newcommand{\PTCA}{\mathbf{PTCA}}
% \newcommand{\Ss}{\mathbb{S}}
% \newcommand{\Os}{\mathbb{O}}
% \newcommand{\Bool}{\mathbb{B}}
% \newcommand{\Nat}{\mathbb{N}}
% \newcommand{\Qs}{\mathbb{Q}}
% \newcommand{\Vv}{\mathbb{V}}
% \newcommand{\POLY}{\mathsf{POLY}}
%
% \newcommand{\zero}{\mathbf{0}}
% \newcommand{\one}{\mathbf{1}}
%
% \newcommand{\eepsilon}{\epsilon}
% \newcommand{\bool}{\mathbf{b}}
%
% \newcommand{\odd}{\mathit{odd}}
% \newcommand{\even}{\mathit{even}}
% \newcommand{\eq}{\mathit{eq}}
%
% \newcommand{\Cyl}{Cyl}
%
% \newcommand{\PCyl}{Pcyl}
% \newcommand{\NCyl}{Ncyl}
% \newcommand{\cyl}{cyl}
% \newcommand{\CylP}{\Cyl P}
%
% \newcommand{\rt}{\mathbf{rt}}
%
% \newcommand{\meas}{\nu}
%
% \newcommand{\sig}{\m{\sigma}}
%
%
%
%
%
% \newcommand{\longv}[1]{}
%
%
%
%
%
%
%
%
%
% %%% NEW
%
%
%
% \newcommand{\ovverline}[2]{{\underline {#1}}_{#2}}
% \newcommand{\porif}{f_{\mathit{if}}}
% \newcommand{\Sf}{S}
% \newcommand{\listenc}[2]{{\langle #1\rangle}^n_\Ll}
%
%
% \newcommand{\doubling}{doub}
% \newcommand{\halving}{halv}
%
%
%
% \newcommand{\dyad}{\emph{dyad}}
\newcommand{\dy}{\emph{dy}}
%
% \newcommand{\ext}{ext}




% %%% CLASS PPT
% \begin{defn}[Class $\PPT$]
% The \emph{class $\PPT$} is the class of functions
% from $\Ss$ to $\mathbb D(\Ss)$
% which are computable by a PTM in a polynomial
% number of steps.
% \end{defn}
% %
% %
% \noindent
% We show that for each $f\in \PPT$,
% the probability that $f(x)=y$ is equal to the measure
% of the set of $\omega$ in the
% corresponding function of $\POR$,
% returning $y$ on input $x$, and vice-versa.
% %
% Formally,
% %
% % Conjecture
% \begin{conj}\label{conj1}
% \begin{enumerate}
% \itemsep0em
% \item[i.] For each $f\in \PPT$, there is $g \in \POR$
% such that:
% $$
% \forall x, y. \emph{Pr}\big(f(x)=y\big) = \mu\big(\{
% \omega \in \Os \ | \ g(x,\omega)=y\}\big).
% $$
%
% \item[ii.] For each $g\in \POR$, there is an $f\in \PPT$
% such that:
% $$
% \mu\big(\omega \in \Os \ | \ g(x,\omega) = y\}\big)
% = \emph{Pr}\big( f(x) =y \big).
% $$
% \end{enumerate}
% \end{conj}
%
% % Proof Sketch
% \begin{proof}[Proof Sketch]
% First, we introduce an auxiliary class of functions,
% $\SFP$, which is strongly related to $\PPT$,
% but based on a source of randomness close
% to that of $\POR$, Section~\ref{sec:SFP}.
% %
% Then, we actually relate the class $\SFP$
% with $\POR$, Section~\ref{sec:SFPtoPOR},
% and vice-versa, Section~\ref{sec:PORtoSFP}.
% \end{proof}













%%%%%% SECTION
%%%%%% THE CLASS SFP
\section{The Class $\SFP$}\label{sec:SFP}
In the perspective of Conjecture~\ref{conj1},
Probabilistic Turing machines
are not suitable computational models.
But they are anyway needed to prove our claim,
because the definition of the $\PPT$ class
relies on these machines. Moreover,
$\BPP$ and other probabilistic complexity classes
are defined on top of the definition of PTMs,
so a characterization of these classes must pass through
the characterization of $\PPT$ functions. In Chapter
\ref{chap:preliminaries}, we have already
defined that computational model and the class of $\PPT$
functions (Definitions \ref{def:ptm} and \ref{def:ppt}).

\noindent
As we stated above, in the perspective of
Conjecture~\ref{conj1}, PTMs are not a suitable
computational model.
Indeed, the source of randomness in a PTM is ``implicit'',
as coming from a \emph{uniform distribution of
probability}, and this affects the machine
output, lifting it from a plain string, to a
distributions of strings.
%
On the other hand, in $\POR$,
randomness is enucleated by the oracle function,
$Q$
%$\omega : \Ss \longrightarrow \Bool$, and
%its functions output strings, not probability distributions.
returning strings (not probability distributions).


To bridge this gap %between $\PPT$ and $\POR$,
we introduce the \emph{class $\SFP$},
which is based on
a better-fitting computational model,
namely \emph{stream Turing machines}
(STM, for short).
%
In STMs, the source of randomness
consists in an ``explicit'', read-only
random tape.
%
More precisely, these machines can be defined
as ordinary
TMs with $k+1$ tapes,
one of which is designated as a read-only \emph{oracle},
and stores an infinite stream of characters to
be read from left to right.
%
These machines are a valuable intermediate
model, linking $\POR$ and $\PPT$.
%
On the one hand, they use the oracle tape as an \emph{explicit}
source or randomness,
that can be represented
as a function $\eta:\Nat \longrightarrow \Bool$,
whose role
is similar to $\omega$'s one in $\POR$.
%
On the other hand, STMs share many features with
multi-tape TMs.\footnote{Conversely,
we can see
a TM as special STM, which basically ``ignores'' the
oracle tape.}
%
Thus, many well-known results
about the latter model still hold.
%
% Intuitively, the class of functions computed by STM
% is almost equivalent to that of the ones computable
% by PTMs.



%%% DEFN Stream Turing Machine
\begin{defn}[Stream Turing Machine]\label{df:streamMachine}
A \emph{stream Turing machine} is a quadruple
$M:= \langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta} \rangle$, where:
\begin{itemize}
\itemsep0em
\item $\m{\Qs}$ is a finite set of states ranged over by
$\m{q_i}$ and similar meta-variables.
%
\item $\m{q_0} \in \m{\Qs}$ is an initial state.
%
\item $\m{\Sigma}$ is a finite set of characters
ranged over by $\m{c_i}$ \emph{et simila}.
%
\item $\m{\delta}: \m{\hat{\Sigma}}
\times \m{\Qs} \times \m{{\hat{\Sigma}}} \times
\Bool
\longrightarrow \m{\hat{\Sigma}} \times \m{\Qs} \times \m{\hat{\Sigma}} \times \{\m{L},\m{R}\}$
is a transition function describing the new configuration
reached by the machine.
\end{itemize}
\m{$L$} and \m{$R$} are two fixed and distinct symbols,
e.g.~\m{$\zero$} and \m{$\one$},
$\m{\hat{\Sigma}}=\m{\Sigma} \cup \{\m{\blank}\}$
and \m{$\blank$} represents the
\emph{blank character}, such that $\m{\blank} \not \in
\m{\Sigma}$.
\end{defn}
%
\noindent
Without loss of generality,
we can assume
$\m{\Sigma}=\{\m{\zero}, \m{\one}\}$,
and define the canonical STM as follows:




%%% DEFN
%%% Canonical STM
\begin{defn}[Canonical STM]\label{df:canonicalSTM}
A \emph{canonical stream machine} is an STM,
such that
$\m{\Sigma}=\{\m{\zero}, \m{\one}\}$.
%$\m{L}=\m{\zero}$, and $\m{R}=\m{\one}$.
\end{defn}


%%% Notation
%\begin{notation}
%In the following, let us use $\m{c}_{|\m{\Sigma}|+1}$ to denote the blank character $\m{\blank}$.
%\end{notation}



The \emph{configuration} of a  STM is
a tuple which keeps track of the current state
and some other objects representing the state of the
machine tape(s).
%
The portion of the oracle tape
which has not been
queried yet is represented by means of a function
$\m{\eta} : \Nat \longrightarrow \Bool$.


%%% DEFINITION
%%% CONFIGURATION
\begin{defn}[Configuration of STM]\label{df:STMConfiguration}
The \emph{configuration of an STM}
is a quadruple $\langle \m{\sigma},
\m{q}, \m{\tau}, \m{\eta}\rangle$,
where:
\begin{itemize}
\itemsep0em
%
\item $\m{\sigma} \in \hat{\Sigma}^*$
is the portion of the work tape on the left of the head;
%
\item $\m{q}\in A$ is the current state of the machine;
%
\item $\m{\tau} \in \hat{\Sigma}^*$ is the portion of the
work tape on the right of the head;
%
\item $\m{\eta} \in \Bool^\Nat$ is the portion
of the oracle tape that has not been read yet.
\end{itemize}
\end{defn}
%
%
\noindent
At each step, the machine queries a new value
on the oracle tape.
%
Shifting on the work tape is naturally defined by
pre-fixing and post-fixing characters to strings,
so formalized by a shifting operation
between the function $\m{\eta}$
and a string $\m{\sigma}$.



%%% DEFINITION
%%% Shifting Operation
\begin{defn}[Shifting Operation]\label{df:shifting}
Given $n\in \Nat$, $\m{\sigma} \in \Ss$, and
$\m{\eta}:\Nat \longrightarrow \Bool$,
we define the \emph{shifting of $\m{\eta}$
by %prefix
$\m{\sigma}$},
$\m{\sigma \eta}(\cdot)$,
by induction on the structure of $\m{\sigma}$:
\begin{align*}
(\m{\eepsilon} \m{\eta})(n) &:= \m{\eta}(n) \\
%
(\m{\bool \tau}) \m{\eta}(n) &:= \begin{cases}
\m{\bool} \ \ \ &\text{if } n=0 \\
(\m{\tau \eta})(n-1) \ \ \ &\text{otherwise.}
\end{cases}
\end{align*}
\end{defn}


The dynamics of STMs is defined
as predictable by extending the notion of standard
transition function in the natural way.


%%% DEFINITION
%%% STM Transition Function
\begin{defn}[STM Transition Function]\label{df:STMTransition}
Given an STM, $M=\langle
\m{\Qs}, \m{q}, \m{\Sigma}, \m{\delta}\rangle$,
we define the \emph{partial transition function}
$\vdash_{\delta} \hat{\Sigma}^* \times
\Qs \times \hat{\Sigma}^* \times
\Bool^\Nat \longrightarrow
\hat{\Sigma}^* \times
\Qs \times \hat{\Sigma}^*
\times \Bool^\Nat$
between two configurations as:
%
\begin{align*}
\langle \m{\sigma}, \m{q}, \m{c\tau}, \m{\bool\eta}\rangle
%
\stmtrans_{\delta}
%
\langle \m{\sigma c'}, \m{q'}, \m{\tau}, \m{\eta}\rangle
%
\ \ \ \ \ &\text{if} \ \m{\delta}(\m{q},\m{c},\m{\bool}) =
\langle \m{q'}, \m{c'}, \m{R}\rangle \\
%
%
%
\langle \m{\sigma c_0},
\m{q}, \m{c\tau},
\m{\bool\eta \rangle}
\stmtrans_{\delta}
\langle \m{\sigma},
\m{q'}, \m{c_0c_1'\tau},
\m{\eta}\rangle
%
\ \ \ \ \ &\text{if} \ \m{\delta}(\m{q}, \m{c_1},
\m{\bool}) = \langle
\m{q'}, \m{c_1'}, \m{L}\rangle
%
%
%
% \langle \m{\sigma}, \m{q}, \m{c\tau}, \m{\one\eta}\rangle
% %
% \stmtrans_{\delta}
% \langle \m{\sigma c'}, \m{q'},
% \m{\tau}, \m{\eta}\rangle
%
% \ \ \ \ \ &\text{if } \m{\delta}(\m{q}, \m{c}, \m{\one})
% = \langle \m{q'}, \m{c'}, \m{R}\rangle \\
% %
% \langle \m{\sigma c_0}, \m{q}, \m{c_1\tau}, \m{\one \eta}\rangle
% \stmtrans_{\delta}
% \langle \m{\sigma}, \m{q'}, \m{c_0c_1' \tau},
% \m{\eta}\rangle
% %
% \ \ \ \ \ &\text{if }
% \m{\delta}(\m{q},\m{c_1},\m{\one}) = \langle
% \m{q'},\m{c_1'},\m{L}\rangle.
%
\end{align*}
\noindent
with $\bool \in \{\zero, \one\}$.
%
\end{defn}
%
%
%
\noindent
The configuration reached by the machine
after $n$ steps of computation is obtained
by composing $n$ times
its reachability function, defined below.


%%% DEFINITION
%%% REACHABILITY FUNCTION
\begin{defn}[STM Reachability Function]\label{df:STMReachability}
Given a STM,
$M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
we indicate with $\{\stmreach^n_M\}_n$ the smallest
family of relations such that:
%
%
%
\small
\begin{align*}
\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle
&\stmreach^0_M
\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle \\
%
%
\big(\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle
\stmreach^n_M
\langle \m{\sigma'}, \m{q'}, \m{\tau'},\m{\eta'}\rangle\big)
%
\wedge
%
\big(\langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\eta'}\rangle
%
&\stmtrans_\delta
%
\langle \m{\sigma''}, \m{q''}, \m{\tau''}, \m{\eta''}\rangle\big)
\rightarrow
\big(\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle
\stmreach^{n+1}_M
\langle \m{\sigma''}, \m{q''}, \m{\tau''},\m{\eta''}\rangle\big).
\end{align*}
\end{defn}
\normalsize
%
%
%
%
\noindent
Without loss of generality,
we assume STMs not to be defined based on final states:
computation is regarded as concluded
whenever the current configuration does
not define the transition function.\footnote{Indeed,
in all these cases,
we could imagine to add a final state $q_F$
and a transition to that state for each blocking configuration.}


\begin{prop}\label{prop}
For any STM,
$M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma},\m{\delta}\rangle$
and $n\in \Nat$,
$\stmreach^n_M$ is a \emph{partial} function.
\end{prop}













\begin{notation}[Final Configuration]
  \label{def:STMFinalConfiguration}
Given an STM,
$M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
and a configuration
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle$,
we write
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle \not\stmtrans_{\delta}$
when there are no $\m{\sigma'}, \m{q'}, \m{\tau'}, \m{\eta'}$
such that
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle
\stmtrans_{\delta} \langle \m{\sigma'}, \m{q'},
\m{\tau'}, \m{\eta'}\rangle$.
\end{notation}
%
%
%
\noindent
Finally, let us introduce the notion of function computable by (poly-time) STMs.





%%% COMPUTATION of STM
\begin{defn}[STM Computation]\label{df:STMcomputation}
Given an STM,
$M = \langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
$\eta:\Nat \longrightarrow \Bool$ and a function
$g : \Nat \longrightarrow \Bool$,
we say that
\emph{$M$ computes $g$},
written $f_M = g$ if and only if for every
string $\sigma\in \Ss$,
and oracle tape $\m{\eta} \in \Bool^\Nat$,
there are a number $n\in \Nat$, $\m{\tau}\in \Ss, \m{q'} \in \Qs$,
and a function
$\m{\psi} : \Nat \longrightarrow \Bool$ such that:
$$
\langle \m{\eepsilon}, \m{q_0}, \m{\sigma}, \m{\eta}\rangle
\ \stmreach^n_M \
\langle \m{\gamma}, \m{q'}, \m{\tau}, \m{\psi}\rangle
\not\vdash_{\delta},
$$
%for some $\m{\tau}, \m{q'$} and $\m\psi$ and
with $f_M(\sigma, \eta)$ being
the longest suffix of $\m{\gamma}$ not including
$\m{\blank}$.
\end{defn}



\begin{defn}[poly-time Stream Machine]\label{df:PSTM}
A \emph{poly-time stream machine}
is an STM,
$M= \langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$
such that:
$$
\exists p\in \textsf{POLY}.
\forall \m{\sigma} \in \Ss,
\eta \in \Bool^\Nat.
\exists n \leq p(|\m{\sigma}|)
\big(\langle \m{\eepsilon},
\m{q_0}, \m{\sigma}, \m{\eta} \rangle
\stmreach^n_{M}
\langle \m{\gamma}, \m{q'}, \m{\tau}, \m{\psi}\rangle \not\vdash_{\delta}.
$$
\end{defn}
%
%
\noindent
We call $\SFP$ the class of functions which
are computable by poly-time STMs.


%%% The Class SFP
\begin{defn}[The Class $\SFP$]\label{df:SFP}
$$
\SFP := \{ f \in \Ss \times \Bool^\Nat\longrightarrow \Ss \ | \
f = f_{M} \text{ for some canonical poly-time STM }M\}.
$$
\end{defn}
%
%
\noindent



\begin{remark}
All definitions given so far concern single-input,
single-tape machines only.
%
We could naturally generalize them as
multi-input and multi-tape machines
in the standard way.
\end{remark}





Finally, the notion of initial prefix of an
oracle tape is also crucial:
we will show that a polynomially long prefix
of the oracle tape is sufficient to determine
the value of the function.


%%%% Prerfix of Oracle Tape
\begin{defn}[Prefix of Oracle Tape]
  \label{def:etaprefix}
For each function $\eta : \Nat \longrightarrow \Bool$,
$\sigma \in \Ss$ and $n \in \Nat$, we define $\eta_n$ as:
$$
\eta_n = \sigma \ \ \ \Leftrightarrow \ \ \forall i<n. \eta(i)=
{\sigma(i)}.
$$
\end{defn}
%
%
\noindent


%%% LEMMA
% \begin{lemma}[Identity of Prefix]\label{lemma:idPrefix}
% For any number $n\in \Nat$ and functions
% $\eta, \eta': \Nat \longrightarrow \Bool$ the $n$-long
% prefix of which are
% the same, i.e.~$\eta_n=\eta'_n$,
% strings $\m{\sigma},\m{\tau}\in\Ss$,
% and state
% $\m{q}\in \Qs$,
% $$
% \langle \m{\sigma},
% \m{q}, \m{\tau}, \m{\eta}\rangle \stmreach^n_\delta
% \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi}\rangle
% \ \ \ \Leftrightarrow
% \ \ \ \langle\m{\sigma}, \m{q}, \m{\tau}, \m{\eta'}\rangle
% \stmreach^n_\delta
% \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\chi}\rangle.
% $$
% for some $\xi, \chi \in \Ss$.
% \end{lemma}


%\begin{cor}\label{cor:idPrefix1}
%For any $n\in \Nat, \eta, \eta': \Nat \longrightarrow \Bool$, such that $\eta_n=\eta'_n$, then for any $\m{\sigma},\m{\tau}\in\Ss$, $\m{q}\in \Qs$, there are some $\xi,\chi$ such that:
%$$
%\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle \overline{\triangleright}^n_\delta \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi}\rangle \ \ \ \Leftrightarrow \ \ \ \langle\m{\sigma}, \m{q}, \m{\tau}, \m{\eta'}\rangle \overline{\triangleright}^n_\delta \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\chi}\rangle.
%$$
%\end{cor}


%\begin{cor}\label{cor:idPrefix2}
%For any $n\in \Nat, \eta, \eta': \Nat \longrightarrow \Bool$, such that $\eta_n=\eta'_n$, then for any $\m{\sigma},\m{\tau}\in\Ss$, $\m{q}\in \Qs$, there are some $\xi,\chi$ such that:
%$$
%\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\eta}\rangle \overline{\underline{\triangleright}}^n_\delta \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi}\rangle \ \ \ \Leftrightarrow \ \ \ \langle\m{\sigma}, \m{q}, \m{\tau}, \m{\eta'}\rangle \overline{\underline{\triangleright}}^n_\delta \langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\chi}\rangle.
%$$
%\end{cor}
































































%%%%%%%%
\noindent
Before going on, notice that $\POR$ and $\SFP$
are two inherently different sets:
\begin{align*}
\POR \subseteq \bigcup_{i\in \Nat} \Ss^i \times
\Bool^\Ss \longrightarrow \Ss \\
%
\SFP \subseteq \bigcup_{i\in \Nat} \Ss^i \times
\Bool^\Nat \longrightarrow \Ss.
\end{align*}
%
Thus, some effort is required
to relate these two classes
%
and, actually, %as we shall see,
the correspondence obtained in this
context is weaker than the one between
$\Sigma^b_1$-formul\ae{} representable in
$\RS$ and $\POR$, from
Sections~\ref{sec:TaskA} and~\ref{sec:TaskB}.
%
Differently from formul\ae{} of $\Lpw$
and functions in $\POR$,
which have access to their source of randomness
in almost the same way,
we cannot define a precise identity between $\SFP$
and $\POR$.
%
We could relate sets of (oracle) functions,
\emph{which are not the same}, by considering
their measure,
and
obtain a weaker (but strong enough) result,
providing encodings between the two classes,
which preserve measures of the random sources
associated to the given input and output.


\begin{theorem}\label{thmTaskC}~
\begin{itemize}

\item[i)] For each $f \in \SFP$, there is a $g \in \POR$ such that for every $x,y\in \Ss:$
$$
\mu\big(\{\eta \in \Bool^\Nat \ | \  f(x,\eta) = y\}\big) = \mu\big(\{\omega \in \Os \ | \ g(x,\omega)=y\}\big).
$$

\item[ii)] For each $g\in \POR$, there is an  $f \in \SFP$ such that for every $x,y\in \Ss:$
$$
\mu\big(\{\omega \in \Os \ | \ g(x,\omega) = y\}\big) = \mu\big(\{\eta \in \Bool^\Nat \ | \  f(x, \eta) = y\}\big).
$$
\end{itemize}
\end{theorem}

In the two following Sections, we will address the two reductions
separately, namely: in Section \ref{sec:SFPtoPOR}, we will show
that $\SFP$ can be reduced to $\POR$ and in Section
\ref{sec:PORtoSFP} we will prove the converse reduction.
Finally, in Section \ref{sub:SFPtoPPT},
we will establish that a similar relation holds between $\SFP$ and $\PPT$, too.











































































































































































































































































%%%% SECTION
%%%% FROM SFP to POR
%\newpage
\section{From $\SFP$ to $\POR$}\label{sec:SFPtoPOR}
%
%

In this section, we address the first of the two claims in
Theorem \ref{thmTaskC}:

%%% LEMMA
%%% lemma:taskC1
\begin{restatable}{lemma}{lemmataskCone}
\label{lemma:taskC1}
For any $f\in \SFP$, there is $g \in \POR$
such that for every $x,y\in \Ss$,
$$
\mu\big(\{\eta \in \Bool^\Nat \ | \ f(x, \eta)=y \}\big)
= \mu\big(\{\omega \in \Os \ | \ g(x,\omega) =y\}\big).
$$
\end{restatable}

\noindent
When reducing $\SFP$ to $\POR$, we can either build
a direct encoding or not. A direct encoding would require
an on-line management of the probabilistic choices made by
the $\POR$ and the $\SFP$ functions.
This would make the proof cumbersome and probably opaque.
Intuitively, we would need to simulate any function computed
by an STM with the oracle tape associated with
$\m{\eta}$
by means of a
$\POR$-function $g$,
querying a fresh \emph{coordinate} of its
oracle $\omega$ at each simulate step,
in turn emulating
the corresponding value written
on $\m{\eta}$.
From a technical viewpoint, providing such
apparently-natural correspondence between
$\m{\eta}$ and $\omega$ (i.e.~linking functions
in $\Os$ and in $\Bool^\Nat$)
is not trivial.
%
For this reason, we prefer to separate the probabilistic concerns from
the computational ones, ending up with an arguably easier and clearer proof,
paying the cost of introducing two other intermediate formalisms.
%
The first new formalism, called ``\emph{Finite} Stream Turing Machines'',
is defined as a variation of the STM formalism in which the oracle
tape contains a finite-length string, instead of an infinite stream of
characters.
%
On top of the ``\emph{Finite} Stream Turing Machines'', we define a
class of functions which can be computed in polynomial time with
respect to the length of the first input. This class of functions, called $\polyF$, is
strongly related to $\SFP$.
%
Finally, we will identify a subset of $\POR$, namely $\POR^-$:
the largest subset of $\POR$ which can be defined without
the function $Q$. Showing that all the $\polyF$
functions have a correspondent function in $\POR^-$ allows us to
decouple the purely behavioral concerns of the reduction to the
measure-theoretic ones.
%
Indeed, we address the technical problems concerning the actual simulation
of the $\polyF$ machine within our function algebra $\POR^-$ in a first result.
Then, by the trivial inclusion of $\POR^-$ in $\POR$, we obtain that any machine
defining a $\polyF$ function is in $\POR$ as well. Thus, \emph{in another result}
we establish that the measures of the sets in Lemma \ref{lemma:taskC1} are identical.





%%% proof sketch
Before giving the details of the proof of Lemma \ref{lemma:taskC1},
we would like to outline its main steps,
in order to facilitate the reader in walking through this section.
%
Given an arbitrary $f \in \SFP$ with time bound $p \in \POLY$,
we define a function $h:\Ss \times \Ss \longrightarrow \Ss$
such that:
$$
f(x,\eta) = h\big(x, \eta_{p(|x|)}\big)
$$
where $h$ is ``something'' very close to an ordinary \emph{poly-time} function%
\footnote{The main difference lies in the fact that ordinary poly-time function should take one input only.}; in particular, $f \in \polyF$.
To prove this, we pass
through the corresponding class of machines, as done in
Section~\ref{sec:H}.
%
Then, we define a function $h' : \Ss \times \Ss \times
\Os \longrightarrow \Ss$ such that, for any $x,y\in \Ss$ and $\omega \in \Bool^\Ss$:
$$
h'(x,y,\omega) = h(x,y)
$$
and we prove that $h'\in \POR^-$.
%
Finally, in Section~\ref{sec:E},
we define a function
$e: \Ss \times \Os \longrightarrow \Ss \in \POR$
to mimic the prefix extractor of Definition \ref{def:etaprefix}, namely we
define $e$ such that its output have
\emph{the same distribution} of all possible $\eta$'s prefixes,
but taking a functional argument with different signature.
To do so we need deal with a bijection between $\Ss$ and $\Nat$,
ensuring that for each $\eta \in \Bool^\Nat$
there is an $\omega\in \Bool^\Ss$ such that
any prefix of $\eta$ is an output of
$e(y, \omega)$ for a specific $y$.
Proving $e \in\POR$, since $\POR$ is closed under composition and
$\POR^-\subseteq \POR$, we get the claim. In particular:
%
$$
g(x, \omega) := h'(x, e(x, \omega), \omega).
$$

% Notice that this result entails, as a
% corollary, the fact that Ferreira's PTCA
% is complete with respect to poly-time computation.
% %
% Nevertheless, in order for our proof to be self-contained
% we formally establish this result in
% Section~\ref{sec:G}.
%
\noindent
We will structure the proof as follows:

\begin{itemize}
  \item In Section \ref{sec:preliminary}, we will give the formal
  definitions of $\POR^-$ and $\polyF$.
  \item In Section \ref{sec:H}, we will show that for each $f \in \SFP$
  with time bound $p \in \POLY$ there is a $\polyF$ $h:\Ss \longrightarrow \Ss$
  such that:
  $$
  f(x,\eta) = h\big( x, \eta_{p(|x|)}\big).
  $$
  \item In Section \ref{sec:G}, we show that $\POR^-$ is complete
  with respect to $\polyF$ functions.
  \footnote{And, in particular with to poly-time functions.}
  This entails that there is a function
  $h' \in \POR$ such that:
  $$
  \forall x, y, \omega. h(x, y)=h'(x, y, \omega).
  $$
  \item Then, in Section \ref{sec:E}, we show that $e \in \POR$.
  \item In Section \ref{sec:conclsfp-por}, we join all the results in order to prove the claim.
\end{itemize}












%%%%%% PRELIMINARY NOTIONS
\subsection{Preliminary Notions}\label{sec:preliminary}
The proof of Lemma~\ref{lemma:taskC1},
relies on the introduction of some auxiliary notions.
In particular, we need all the necessary instruments to
show that the function $h$ introduced in the
proof of Lemma~\ref{lemma:taskC1} is actually poly-time.
%
To do so, we define:

\begin{itemize}
\item The class of \emph{Poly-Time Finite Stream Turing Machine} computable functions $\polyF$, defined in Section \ref{sec:poly-timeTM}.
\item A subset of $\POR$ which is expressive enough to capture the class $\polyF$.
This function algebra is defined in Section \ref{sub:por-o}.
\end{itemize}
%
%Although some of them are almost standard,  we briefly present them formally.









%%%%%%%% SUBSECTION
%%%%%%%% poly-time TURING MACHINE
\subsubsection{(Poly-time) Finite Stream Turing Machine}\label{sec:poly-timeTM}


The Finite Stream Turing Machine (FSTM, for short)
are a blending between
STMs, introduced in Section
\ref{sec:SFP} and ordinary Turing Machines.
Basically, they are ordinary Stream Machines, but
with the difference that the second tape can
contain a finite stream of values.\footnote{Some
definitions are omitted but can be found
in Chapter \ref{chap:tech},~Section~\ref{app:c1}}
%
\begin{defn}[Finite Stream Turing Machine]\label{df:FSTuringMachine}
A \emph{Finite Stream Turing Machine} is a quadruple,
$M = \langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
where:
\begin{itemize}
\itemsep0em
%
\item $\m{\Qs}$ is a finite set of states ranged over by the meta-variables
$\m{q_i}$.
%
\item $\m{q_0}\in \m{\Qs}$ is the initial state.
%
\item $\m{\Sigma}$ is a finite set of characters
ranged over by the $\m{c_i}$ meta-variables.
%
\item $\m{\delta} : \m{\hat{\Sigma}} \times
\m{\Qs} \times \m{\hat{\Sigma}} \times \m{\hat{\Sigma}} \longrightarrow \m{\hat{\Sigma}}
\times \m{\Qs} \times \m{\hat{\Sigma}} \times
\{\m{L}, \m{R}\}$
is a transition function describing the new
configuration reached by the machine.
\end{itemize}
$\m{L}$ and $\m{R}$
are two distinct symbols,
$\m{\hat{\Sigma}} = \m{\Sigma} \cup \{\m{\blank}\}$
and $\m{\blank}$ represents the blank character
such that $\m{\blank} \not \in \m{\Sigma}$.
\end{defn}
%
%
%
\noindent
%Without loss of generality, we can assume $\m{\Sigma}=\{\m{\zero}, \m{\one}\}$, and define the canonical TM as follows:
%
%\begin{defn}[Canonical TM]\label{df:canonicalSTM}
A \emph{canonical Finite Stream Turing Machine} is a FSTM,
such that
$\m{\Sigma}=\{\m{\zero}, \m{\one}\}$,
$\m{L}=\m{\zero}$, and $\m{R}=\m{\one}$.
%\end{defn}
%
%
Configurations are defined in the standard way.
%
%Transition function is again as predictable and denoted as  $\tmstep_{\delta}$.


\begin{defn}[FSTM Configuration]\label{df:TMConfiguration}
The \emph{configuration of a FSTM} is a 4-tuple
$\langle \m{\sigma}, \m{q}, \m{\tau},\m{\xi}\rangle$, where
\begin{itemize}
\itemsep0em

\item $\m{\sigma} \in \m{\hat{\Sigma}^*}$ is the portion of the work tape to the left of the head;

\item $\m{q} \in \m{\Qs}$ is the current state of the machine;

\item $\m{\tau} \in \m{\hat{\Sigma}^*}$ is the portion
of the work tape to the right of the head;

\item $\m{\sigma} \in \m{\hat{\Sigma}^*}$ is the portion
of the secondary tape to the right of the head.

\end{itemize}
\end{defn}

\noindent
Now, it is possible to define the TM's transition
function.




%%% DEFINITION
\begin{defn}[FSTM Transition Function]\label{df:FSTMTransition}
Given an FSTM, $M=\langle
\m{\Qs}, \m{q}, \m{\Sigma}, \m{\delta}\rangle$,
we define the \emph{partial transition function}
$\tmstep_{\delta} \m{\hat{\Sigma}^*} \times
\m{\Qs} \times
\m{\hat{\Sigma}^*}\times
\m{\hat{\Sigma}^*}
\longrightarrow
\m{\hat{\Sigma}^*} \times
\m{\Qs} \times
\m{\hat{\Sigma}^*}$
between two configurations as:
%
\begin{align*}
\langle \m{\sigma}, \m{q}, \m{c\tau}, \m{d}\xi \rangle
%
\tmstep_{\m{\delta}}
%
\langle \m{\sigma c'}, \m{q'}, \m{\tau}, \xi\rangle
%
\ \ \ \ \ &\text{if} \ \m{\delta}(\m{q},\m{c}, \m{d}) =
\langle \m{q'}, \m{c'}, \m{R}\rangle \\
%
%
%
\langle \m{\sigma c_0},
\m{q}, \m{c\tau}, \m{d}\xi\rangle
\tmstep_{\m{\delta}}
\langle \m{\sigma},
\m{q'}, \m{c_0c_1'\tau, \xi}
\rangle
%
\ \ \ \ \ &\text{if} \ \m{\delta}(\m{q}, \m{c_1}, \m{d}) = \langle
\m{q'}, \m{c_1'}, \m{L}\rangle.
%
%
%
% \langle \m{\sigma}, \m{q}, \m{c\tau}, \m{d}\rangle
% %
% \tmstep_{\m{\delta}}
% \langle \m{\sigma c'}, \m{q'},
% \m{\tau}\rangle
% %
% \ \ \ \ \ &\text{if } \m{\delta}(\m{q}, \m{c}, \m{d})
% = \langle \m{q'}, \m{c'}, \m{R}\rangle \\
% %
% \langle \m{\sigma c_0}, \m{q}, \m{c_1\tau}, \m{d}\rangle
% \tmstep_{\m{\delta}}
% \langle \m{\sigma}, \m{q'}, \m{c_0c_1' \tau}, \m{d}\rangle
% %
% \ \ \ \ \ &\text{if }
% \m{\delta}(\m{q},\m{c_1}, \m{d}) = \langle
% \m{q'},\m{c_1'},\m{L}\rangle.
%
\end{align*}
%
\end{defn}
%
\noindent
As for STMs, the configuration reached by the machine
$M$ after $n$ steps of computation is obtained
by composing $n$ times
its reachability function, denoted by $\tmreach^n_M$.


\begin{defn}[FSTM Reachability Function]\label{df:TMReachability}
Given a FSTM,
$M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
we indicate with $\{\tmreach^n_M\}_n$ the smallest
family of relations such that:
%
%
%
\small
\begin{align*}
\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle
&\tmreach^0_M
\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle \\
%
%
\big(\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle
\tmreach^n_M
\langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi'}\rangle\big)
%
\wedge
%
\big(\langle \m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi''}\rangle
%
&\tmstep_{\m{\delta}}
%
\langle \m{\sigma''}, \m{q''}, \m{\tau''}, \m{\xi''}\rangle\big)
\rightarrow
\big(\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle
\tmreach^{n+1}_M
\langle \m{\sigma''}, \m{q''}, \m{\tau''}, \m{\xi''}\rangle\big).
\end{align*}
\normalsize
\end{defn}
\noindent
As for TMs and STMs,
we assume FSTMs not to use final states.




\begin{prop}
For any FSTM, $M\langle \m{\Qs}, \m{q_0}, \m{\Sigma},
\m{\delta}\rangle$ and $n\in \Nat$,
$\tmreach^n_M$ is a function.
\end{prop}

\begin{notation}[Final Configuration]
Given a FSTM,
$M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
and a configuration
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle$,
we write
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle \not\tmstep_{\m{\delta}}$
when there are no $\m{\sigma'}, \m{q'}, \m{\tau'}, \m{\xi'}$
such that
$\langle \m{\sigma}, \m{q}, \m{\tau}, \m{\xi}\rangle
\tmstep_{\m{\delta}} \langle \m{\sigma'}, \m{q'},
\m{\tau'}, \m{\xi'}\rangle$.
\end{notation}
%
%
%



%%% poly-time TM
\begin{defn}[Poly-time Finite Stream Turing Machine]\label{df:polyTM}
A \emph{poly-time Finite Stream Turing machine}
is a FSTM, $M=\langle \m{\Qs}, \m{q_0}, \m{\Sigma},
\m{\delta}\rangle$
such that:
$$
\exists p \in \mathsf{POLY}. \forall \m{\sigma}, \m{\tau} \in \m{\Ss}.
\exists n \leq p(|\m{\sigma}|)
\big(\langle \m{\eepsilon}, \m{q_0}, \m{\sigma}, \m{\tau}
\rangle \tmreach^n_M
\langle \m{\gamma}, \m{q'}, \m{\sigma'}, \m{\tau'}\rangle
\not \tmstep_\delta.
$$
\end{defn}

%
% \begin{remark}
%   All these definitions scale naturally to multi-tape Turing machines, if we define
%   the configuration of a $k$-taped TM as a tuple:
%   $$
%     \langle \sigma_1, \ldots, \sigma_k, q, \tau_1, \ldots, \tau_k\rangle
%   $$
%   Where the $\sigma_i$ are the strings on the left of each tape's head, and
%   the $\tau_i$ are the strings on the right of the heads.
% \end{remark}

%%% COMPUTATION of STM
\begin{defn}[FSTM Computation]\label{def:FSTMcomputation}
Given a FSTM,
$M = \langle \m{\Qs}, \m{q_0}, \m{\Sigma}, \m{\delta}\rangle$
and a function $g: \Ss\times \Ss \longrightarrow \Ss$,
we say that \emph{$f_M$ computes $g$}, written $f_M=g$,
if and only if for every
$\sigma, \tau \in \Ss$,
there are a natural number $n\in \Nat$, $\m{\xi}\in \Ss$ and $\m{q'} \in \Qs$,
such that:
$$
\langle \eepsilon, q, \sigma, \tau\rangle \tmreach^n_M
\langle \gamma,  q, \sigma', \tau'\rangle\
$$
%for some $\m{\tau}, \m{q'$} and $\m\psi$ and
with $f(\sigma, \tau)$ being
the longest suffix of $\m{\gamma}$ not including
$\m{\blank}$.
\end{defn}




We are now able to define the class
$\polyF$, namely the class of functions
which are computable by poly-time FSTMs.



%%% Class ?
\begin{defn}[The Class $\polyF$]\label{df:poly-time}
$$
\polyF := \{f \in \Ss \times \Ss \longrightarrow \Ss \ | \ f=f_M \text{for some poly-time FSTM $M$}\}.
$$
\end{defn}

\noindent
The class $\polyF$, basically, is a restriction to a finite stream of random bits
of the class $\SFP$ class.









%%%%%%% SUBSUBSECTION
\subsubsection{The Class $\POR^-$}
\label{sub:por-o}

%
Furthermore, we present the class
$\POR^-$ which is defined as
$\POR$ except for the
absence of the query function $Q$.
%
The reasons why this class is interesting are manifold:

\begin{itemize}
  \item First of all, because we show that it is sound and complete
  with respect to Ferreira's PTCA \cite{Ferreira88}
  (Remarks \ref{rem:cobtopor} and \ref{rem:portocob}).
  This entails that, showing the completeness of $\POR^-$
  respect to $\polyF$ functions
  and the completeness of $\polyF$ functions with respect to
  \emph{ordinary poly-time functions} (Lemma \ref{lemma:polyFcompleteness})
  yields, as a corollary, the proof that
  Ferreira's PTCA contains the class of poly-time
  computable functions.
  \item Obviously we have $\POR^-\subseteq \POR$, and that
  the output of a function in $\POR^-$ does not depend on its oracle $\omega$.
  For this reason, proving the reducibility of $\polyF$ to $\POR^-$,
  we will separate
  the machine-related part of the reduction, which concerns the actual implementation
  of an FSTM machine in $\POR$ from the measure-theoretic aspects of Theorem
  \ref{thmTaskC}.
\end{itemize}

%
\noindent
The completeness of $\POR^-$ with
respect to $\polyF$ functions is proved in Section \ref{sec:G}.



\begin{defn}[The Class $\POR^-$]
The \emph{class $\POR^-$}
is the smallest class of functions
$\Ss^n\times \Os\longrightarrow \Ss$ containing:
\begin{itemize}
\itemsep0em

\item The empty function $E(x,\omega)=\eepsilon$;

\item The projection function
$P^{n}_i(x_1,\dots, x_n,\omega)=x_i$;

\item The word-successor $S_\bool(x,\omega) = x\bool$,
for every $\bool \in \Bool$

\item The conditional function
\begin{align*}
C(\eepsilon, y, z_\zero, z_\one,\omega) &= y \\
C(x\bool, y, z_\zero, z_\one,\omega) &= z_\bool,
\end{align*}
where $\bool \in \Bool$;
\end{itemize}
and closed under:
\begin{itemize}
\item Composition, such that $f$ is defined from
$g,h_1,\dots, h_k$ as:
$$
f(\vec{x}) = g\big(
h_1(\vec{x},\omega), \dots, h_k(\vec{x},\omega),\omega\big);
$$


\item Bounded recursion, such that $f$ is defined from
$g, h_1, h_2$ as:
\begin{align*}
f(\vec{x},\eepsilon,\omega) &:= g(\vec{x},\omega); \\
%
f(\vec{x}, y\zero,\omega) &:= h_1
\big(\vec{x}, y,
 f(\vec{x},y,\omega),\omega\big)|_{t(\vec{x},y)}; \\
%
f(\vec{x}, y\one,\omega) &:=
h_2\big(\vec{x}, y,
f(\vec{x}, y,\omega),\omega\big)|_{t(\vec{x},y)};
\end{align*}
\noindent
where $t$ is defined from $\eepsilon, \zero, \one,
\frown, \times$ by explicit definition.
\end{itemize}
\end{defn}


%\begin{defn}[The Class $\POR^-$]
%The class $\POR^-$ is  the class of functions $\Ss^n\times \Os \longrightarrow \Ss$ containing $E, P^n_i, S_{\bool},  C$, and closed under oracle composition and bounded-recursion.
%\end{defn}











































































































%\newpage
%%%%%% ENCODING

\subsection{From $\SFP$ to $\polyF$}\label{sec:H}
First of all, we show that for any $f\in \SFP$,
the corresponding $\polyF$ function
$h:\Ss \times \Ss\longrightarrow \Ss$ can be constructed.
%
The core idea consists in showing a procedure
to transform a STM into an equivalent FSTM.
%
Indeed, according to Definition~\ref{df:SFP},
there is a poly-time STM $M$, such that $f=f_M$.
%
Thus, we want to construct the corresponding
\emph{poly-time} FSTM $N$, which,
taken for second argument a sufficiently long polynomial prefix of $\eta$,
behaves exactly like $M$.
%
In particular, $N$ is constructed basing on a
two-taped FSTM, whose transition function is exactly
$M$'s.
%
For each computation,
$N$ performs a number of steps which
is \emph{exactly the same number of those performed} by $M$.
So also this standard FSTM must be \emph{poly-time}.



%%% LEMMA
%%% lemma:poly-time
\begin{lemma}\label{lemma:SFPtopolyF}
For each $f\in \SFP$ with time-bound $p\in \POLY$,
there is an $h \in \polyF$ such that
for any $\eta\in \Bool^\Nat$ and $x, y\in \Ss$,
$$
f(x,\eta) = h(x, \eta_{p(|x|)}).
$$
\end{lemma}



%%% Proof of Lemma
\begin{proof}
Assume that $f \in \SFP$.
%
By Definition~\ref{df:SFP},
there is a poly-time STM, $M =\langle \m{\Qs},
\m{q_0}, \m{\Sigma}, \m{\delta}\rangle$,
such that $f=f_M$.
%
Let us define an FSTM $N$
which, given a polynomially long prefix of $\eta$,
behaves like $M$.
%
The Definition of $N$ is identical to the definition of $M$.
Formally,
for any $k\in \Nat$ and some $\sigma,\tau , y' \in \Ss$,
$$
\langle \m{\eepsilon}, \m{q_0'}, \m{x}, \m{y} \rangle
\triangleright^k_{\delta'} \langle \m{\sigma},
\m{q}, \m{\tau}, \m{y'}\rangle
\ \ \ \Leftrightarrow \ \ \
\langle \eepsilon, q_0', x, y\eta\rangle
\stmreach^k_\delta
\langle \g{\sigma}, \g{q}, \g{\tau}, \g{y'\eta}\rangle.
$$
Moreover,
$N$ requires a number of steps which is exactly equal to
the number of steps required by $M$, and thus
is in $\polyF$, too.
%
We conclude the proof defining $h=f_{N}$.
\end{proof}













































































%\newpage
%%%%%%%
%%%%%%%
%%%%%%% FROM PTF TO POR
\subsection{From $\polyF$ to $\POR^-$}\label{sec:G}

In this section we will show that all those functions which are in $\polyF$
can be represented in $\POR^-$, too. This can be formalized as follows:

%%% LEMMA
\begin{restatable}{lemma}{polyFtoCob}
\label{lemma:polyFtoCob}
  For any $f\in \polyF$ and $x\in \Ss$,
  there is $g\in \POR^-$
  such that
  $
  \forall x, y, \omega. f(x, y)=g(x, y,\omega).
  $
\end{restatable}

\begin{proof}[Proof Sketch]
  Any configuration of an FSTM
  can be encoded in a string, thus we
  can pass the encoding of the initial machine's configuration
  to a function which emulates the execution of the machine which computes $f$
  (called $M_f$) for
  a polynomial number of steps.
  When $M_f$ reaches a final configuration, it is sufficient to extract
  from the final configuration the longest portion of the primary tape
  which is on the left and free form $\circledast$ characters.
\end{proof}

Formally proving Lemma \ref{lemma:polyFtoCob} requires a lot of work which, for the sake of a clearer presentation can be found in
 Section \ref{sub:encoding} of Chapter \ref{chap:tech}. In this part
we only show that
$\POR^-$ enjoys three important properties which entail Lemma \ref{lemma:polyFtoCob}:

\begin{itemize}
  \item It is possible to encode FSTMs, together with configurations
  and their transition functions simply using strings. Moreover,
  there is a function $\apply \in \POR^-$ which, receiving as input
  the encoding of a FSTM configuration $c$ and the encoding of a
  FSTM transition function $\delta$, computes the encoding
  configuration obtained applying the function $\vdash_\delta$
  on $c$. Intuitively, the $\apply$ function simulates the outcome
  of a computation step onto a FSTM configuration.
  \item For each $f \in \POR^-$ and $x, y \in \Ss$ if there is a
  term $t(x)$ in $\Lpw$
  bounding the size of $f(x, \omega)$ for each $\omega$, then there is a function which
  applies $|y|$ times $f$ on its own output.
  \item There is a function $\dectape$ which extracts
  the machine's output from any encoded final configuration of an FSTM machine.
\end{itemize}

\subsubsection{The Function $\apply$}
\label{subsub:apply}

To define $\apply$, we show that given the encoding of a finite function\footnote{For details, see Corollary \ref{cor:deltarepr} in Chapter \ref{chap:tech}}, can be
\emph{interpreted} by means of a $\POR^-$ function,
the \emph{total function simulator} called $\simulate$.\footnote{We call it \emph{total} because,
since $\POR^-$ is total, it defines a default value to be returned when the
simulated function is not defined on the queried input.}

The $\simulate$ function is defined by induction on the number of elements
in the encoding of the simulated function
(the number of pairs in the function's graph). This value is obtained by means
of the function
$\pi_0(y,\omega)$ which, as shown in Remark \ref{rem:pojectors},
returns the number of element in a collection, assuming that such collection
is represented on top of lists, as in this case.
Said this value $n$, for each $1 \le i \le n$,
the function  $\simulate'$ extracts the
$i$-th projection from the function's graph and compares its first element with
the queried value. If these values are identical,
then it returns the second projection of
the pair, otherwise it proceeds recursively.

\begin{defn}[Total Function Simulator]
We define the \emph{total function simulator}
$\simulate(\cdot, \cdot, \omega)$ as follows:
\begin{align*}
\simulate'(y,x,\eepsilon,\omega) &:= \eepsilon; \\
%
\simulate'(y,x,z\bool, \omega) &:= \mathit{if}\big(\pi_2(\pi(y,z\bool,\omega),
\omega), \simulate'(y,x,z,\omega), eq(\pi_1(\pi(y,z\bool,\omega),
\omega), x,\omega), \omega\big); \\
\\
\simulate(x,y,\omega) &:= \simulate'\big(y,x,\pi_0(y,\omega),\omega\big).
\end{align*}
\end{defn}

%
The formal proof of the correctness of this function is in Chapter \ref{chap:tech},
Lemma \ref{lemma:simcorr} and the implementative details of the functions and
the encoding employed can be found in Section \ref{sub:encoding} of Chapter \ref{chap:tech}.

As a consequence of $\simulate \in \POR$,
it holds that there is a function $\apply$ in $\POR$ which,
given a transition function $\delta$, simulates the function $\vdash_\delta$
on the encodings of machine's configuration.
The formal proof of this property (Lemma \ref{lemma:applycorr}), together
with the definition of the function $\apply$ are quite cumbersome. For this
reason, they are given in Chapter \ref{chap:tech}, Section \ref{app:secg}.
The correctness of $\apply$ is stated as follows:

\begin{restatable}[Correctness of $\apply$]{lemma}{applycorr}
  \label{lemma:applycorr}
  The function $\apply$ is such that for any FSTM $M$ with transition function
  $\delta$, said $x_\delta$ and $h(c)$ respectively, the given encodings
  of $\delta$ and the encoding of a configuration $c$,\footnote{These encodings
  exist as a consequence of Corollaries
  \ref{cor:deltarepr} and \ref{cor:confrepr}. In what follows, the
  functions thereby described will be considered the canonical encoding of
  FSTM transition functions and configurations within $\POR$.}
  \begin{align*}
    \forall \omega \in \Os.\vdash_\delta(c)=d \to \apply(x_\delta, h(c), \omega) = h(d);\\
    \forall \omega \in \Os. \left(c \not\vdash_\delta\right ) \to \apply(x_\delta, h(c), \omega) = h(c).
  \end{align*}
\end{restatable}
%
\noindent
%
Here, assuming that Lemma \ref{lemma:applycorr} holds, we show how it is possible
to employ the function $\apply$ to prove Lemma \ref{lemma:polyFtoCob}.

\subsubsection{Power Function}
\label{subsub:pf}

In this section, we show that for each function in $\POR^-$, if
the size of its outputs
is bounded by a term in $\Lpw$, then its $n$-th power is in $\POR^-$.
%
Thanks to this result, we will be able to compute the polynomial transitive
closure of $\apply$, in order to compute the final configuration
of any FSTM, given its $\delta$ function and its input.

To this end, we define the function schema $\sa_{\cdot,\cdot}$,
which allows us to compute
the transitive closure of the function $\apply$. To do so,
we must show that the growth of the terms computed by $\apply$
is under control. This is due to the fact that the only iterative
mechanism of $\POR^-$ is bounded recursion on notation, which
requires that, at each step, the function outputs are bounded in size.
%
So, the self-application schema must pass through bounded recursion on notation
and thus, it requires size bounds. For this reason, we show that the term-growth
of the size growth of the output of the function $\apply$ is at most constant.
This is done in Lemma \ref{lemma:applysize}

\begin{restatable}{lemma}{saPOR}
  \label{lemma:saPOR}
  For each $f : \Ss^{k+1} \times \Os \longrightarrow \Ss \in \POR$,
  if there is a term $t \in \Lpw$ such that
  $\forall x, \vec z, \omega. f(x, \vec z, \omega)|_t = f(x, \vec z, \omega)$
  then there is also a function $\sa_{f, t} : \Ss^{k+2} \times \Os \longrightarrow \Ss$
  such that:
  $$
  \forall n \in \Nat. \forall x \in \Ss,  \omega \in \Os.
  sa_{f, t}(x, \ovverline n \Nat, \vec z, \omega) =
  \underbrace{f(f(f(x, \vec z,  \omega), \vec z, \omega), \ldots)}_{n\text{ times}}.
  $$
\end{restatable}

\noindent
For sake of readability, we prove this result and define the
$\sa_{\cdot, \cdot}$ function schema in Chapter \ref{chap:tech}, the details
are in Section \ref{proof:saPOR}.
%

\begin{restatable}[$\apply$ Size Growth]{lemma}{applysize}
  \label{lemma:applysize}
  For all $x_c\in \Ss$ being the encoding of an FSTM configuration
  and for each encoding of a transition function $\delta$
  in a string $x_\delta \in \Ss$ and for each $\omega\in \Os$, there is
  a $k \in \Nat$ such that
  $\apply(x_c, x_\delta, \omega)|_{x_c\one^k}$.
\end{restatable}

\noindent
The specific value of the size bound expressed in the lemma above
is not particularly meaningful, and it is
mainly due to the encodings we decided to adopt, while it is important that
fixed a FSTM machine we can always find such $k$.
Even in this case, the technical proof of this result is in
Chapter \ref{chap:tech} (Section \ref{proof:applysize}).








%%%%% REPRESENTING TRANSITION IN COB
\subsubsection{Representing Transition in $\POR^-$}

In this section, we show that it is possible to define a function
$\dectape \in \POR^-$ which takes in input the encoding of a tape and
$\omega \in \Os$, and returns the longest suffix of the tape on the left of the
head without any occurrence of $\circledast$. This requires us to do some
technical work. First, we show that
some auxiliary functions are in $\POR^-$; these functions are:
the difference function $\mathit{diff}$ returning the difference
between two numbers,
the list-projector function $\pi_n$
taking (the encoding of) a list
and a number $n$ as its input and returning
the $n$-th element of the list,
and the right-remover function $\rrs$.
Moreover, it also depends on a couple of control-related functions
the string identity predicate $eq: \Ss^2 \times \Os \longrightarrow \Ss$
and the control structure
$\mathit{if}: \Ss^3 \times \Os \longrightarrow \Ss$, thus
we show that even those two functions are in $\POR^-$.\footnote{Formal
definitions are presented in Chapter \ref{chap:tech}, Section~\ref{sec:dynenc}.}
%
%
%
%
%
%
While decoding the final configuration of a
canonical TM,
we need to extract the longest
sequence of bits on the immediate
left of the head.
%
To do so, we introduce an auxiliary
function $\rho:\Ss^2\times \Os \longrightarrow \Ss$
that is supposed to take the encoding of a tape
as its input and return the $y$-th right character
of the tape.
Formally,
%
$$
\rho(x,y,\omega) = \pi\big(x,
\mathit{diff}(\pi_0(x,\omega), y,\omega),\omega\big).
$$
Then, we define a \emph{decoding}
function so that, at each step,
checks whether the character obtained from
$\rho$ is the encoding of $\circledast$ of Definition \ref{def:canencs}, i.e.
$\one\one\one$.
If so, it returns $\eepsilon$. ,
This control is done recurring to $eq$.
%







%%%%%% DECTAPE
\begin{defn}[$\dectape$ Function]
  \label{def:dectape}
Let $dec :\Ss\times \Ss \times \Os
\longrightarrow \Ss$ be an auxiliary function defined
as follows:
\begin{align*}
\dectape'(x,\eepsilon,\omega) &:= \eepsilon; \\
\dectape'(x, y\bool,\omega) &:= \mathit{if}\big(\dectape'(x,y,\omega)
\rho (x,y\bool,\omega), \eepsilon,
\lnot eq(\rho(x,y\bool,\omega),\omega), \one\one\one,\omega)\big)|_{x}.
\end{align*}
with
$$
\rho(x,y,\omega) := \pi\big(x,
\mathit{diff}(\pi_0(x,\omega), y,\omega),\omega\big).
$$
We define the function $\mathit{dectape}$:
$\Ss  \times \Os \longrightarrow \Ss$
as follows:
$$
\dectape(x,\omega) := \dectape'\big(x,rrs(\pi_0(x,\omega),\omega),
\omega\big).
$$
\end{defn}
%
%
\noindent
The function $\dectape$ returns a string which is the
longest suffix not including $\circledast$
of the tape encoded with $\ovverline \cdot \Tt$ and stored in $x$.
By Definition~\ref{df:STMcomputation}, this is precisely
the value computed by the machine.
A formal proof of this statement
is given in Chapter \ref{chap:tech}, the details are in Lemma \ref{lemma:dectape}

\begin{lemma}\label{lemma:dectape}
The function $\mathit{dectape}\in \POR^-$
is such that if $\underline{\cdot}_\Tt$
is the encoding for tapes of Definition \ref{def:canencs},
then for any $\sigma\in \{\zero,\one,\blank\}^*$,
$\omega \in \Os$,
$$
\dectape(\underline{\sigma}_\Tt, \omega) = \tau
$$
and $\tau$ is the longest suffix of $\sigma$ without $\blank$.
\end{lemma}

\noindent
Let us also define a function \emph{size}
which allows us to compute the
encoding of the size of a string throughout
$\underline{\cdot}_\Nat$.
\begin{defn}
The function $\mathit{size} : \Ss\times \Os \longrightarrow \Ss$
is defined as follows:
\begin{align*}
\mathit{size}(\eepsilon, \omega) &:= \one; \\
\mathit{size}(x\bool,\omega) &:= \mathit{size}(x,\omega)\one|_{x\one\one}.
\end{align*}
\end{defn}
\noindent
The correctness of the function $\mathit{size}$, with respect to the
encoding we are adopting --- namely $n \mapsto\one^{n +1}$ ---
can be shown by induction.













%%%%% CONCLUDING THE PROOF
\subsubsection{Composing the Pieces}
It is now possible to show that for every
$\polyF$-function there is
a corresponding function in $\POR^-$.
%
The conclusion is the \emph{composition} of three main ingredients:
\begin{itemize}
  \item Machine steps can be simulated by means of the function $\apply$.
  \item The function $\apply$ can be self-applied a polynomial numbers of times.
  \item We can extract the value computed by the machine by its final configuration.
\end{itemize}

These results allow us to give a proof to Lemma \ref{lemma:polyFtoCob}.
% Namely,
% that for each function $f: \Ss \times \Ss \longrightarrow \Ss$ in $\polyF$,
% there is a function $g: \Ss \times \Ss \times \Os\in \POR^-$, which has the same behavior
% with respect to the two string parameters, independently from the value of the oracle.
%such that for every $x, y \in \Ss$ and for every $\omega \in \Os$, it holds that $f(x,y)=g(x, y, \omega)$.




%%% LEMMA
\polyFtoCob*
% \begin{lemma}\label{lemma:polyFtoCob}
% {For any $f\in \polyF$ and $x, y\in \Ss$,
% there is a $g\in \POR^-$,
% such that
% $
% \forall \omega \in \Os. f(x, y)=g(x, y, \omega).
% $}
% \end{lemma}
%% PROOF
\begin{proof}
%
By definition of $\polyF$,
there is an FSTM computing $f$ on a machine $M$ with a polynomial
time-bound, $p$, and a transition function $\delta$.
%
Let us consider a function $g$
defined as follows:
$$
g(x, y, \omega) = dectape(\pi_{1}(sa_{\apply, t_M}(x_\delta,
\langle \ovverline \circledast \Tt, \underline{0}_\Nat, \ovverline x\Tt, \ovverline y\Tt\rangle_\Ll^4,
\underline p(\mathit{size}(x, \omega), \omega), \omega), \omega), \omega)
$$
where $\underline p$ is the $\POR^-$-function which
computes the encoding of the value of the polynomial $p$.\footnote{
This function is in $\POR^-$, because we have shown that this class
contains all the polynomials, details are in Corollary \ref{cor:polyinpor}.}
This function is correct as the self-application of $\apply$ for $p(|x|)$
times returns in the machine configuration, as a consequence of Lemma \ref{lemma:applycorr}.
Finally, $\mathit{dectape}$
extracts the longest suffix free from blank characters
which is on the left of the head
in the encoding of the tape reached at the end of the computation.
This is a consequence of the correctness of the projector $\pi_1$
with respect to the encoding of lists
(for details, see Chapter \ref{chap:tech}, Section \ref{sub:encoding})
and of the correctness of $\dectape$ (Lemma \ref{lemma:dectape}).
As required by Definition~\ref{df:STMcomputation}, this is exactly $f(x, y)$.
\end{proof}
%
%
%
%
%
\noindent
Before proceeding with the main result of this section, we would like to
point out that Lemma \ref{lemma:polyFtoCob} entails, as a consequence, that the
polynomial time computable functions are exactly the functions computable by a
canonical Cobham style function algebra. This results is placed in a chapter by its own: Chapter \ref{chap:cobham}.
%
As another consequence of Lemma \ref{lemma:polyFtoCob},
we show the result we were aiming to:
each function $f \in \SFP$ can be simulated by a function in $g\in \POR^-$,
using as an additional input a polynomial prefix of $f$'s oracle.

%%% COROLLARY
\begin{cor}
  \label{cor:sfptopor-}
For each $f\in \SFP$ and polynomial
time-bound $p\in \POLY$,
there is a function $g\in \POR^-$ such that
for any $\eta : \Nat \longrightarrow \Bool$, $\omega : \Nat \longrightarrow \Bool$ and $x\in\Ss$,
$$
f(x,\eta) = g\big(x,\eta_{p(|x|)}, \omega\big).
$$
\end{cor}

%%% PROOF
\begin{proof}
Assume $f\in \SFP$ and $y = \eta_{p(|x|)}$.
By Lemma~\ref{lemma:SFPtopolyF},
there is a function $h\in \polyF$ such that,
for any $\eta :\Nat \longrightarrow \Bool$ and
$x\in \Ss$,
$$
f(x,\eta) = h\big(x,\eta_{p(|x|)}\big).
$$
%
%
Moreover,
due to Lemma~\ref{lemma:polyFtoCob},
there is also a $g\in \POR^-$ such that for every $x, y \in \Ss, \omega \in \Os$,
%
$$
g(x,y, \omega) = h\big( x, y \big).
$$
%
%
Then, the desired function is $g$.
\end{proof}




























































































%\newpage
\subsection{Extractor Function in $\POR$}\label{sec:E}
Finally, we construct the extractor function $e(x, \omega)$
we introduced discussing the proof of Lemma \ref{lemma:taskC1} within $\POR$.
%
Indeed, by means of $e$ we can sample enough random bits from $\omega$ to fill
randomly the oracle-tape of the FSTM machine we are emulating.
%
Intuitively, this function is very simple: extracts $|x|+1$ bits from $\omega$
and concatenates them in its output.
%
The function $e$, in order to sample form $\omega$ a string uniformly at random,
passes through a bijection $\dy: \Nat \longrightarrow \Ss$, called \emph{dyadic
representation} of a natural number. Thus, the $e$ function can simply enumerate
its numerals $\underline 0,_\Nat, \underline 1_\Nat,\underline 2_\Nat, \ldots$, and sample
the corresponding coordinates of $\eta$ obtained throughout $\mathit{dy}$.
Intuitively, for each natural number $n\in \Nat$,
if $n_2$ is the encoding of $n$ in base 2,
the dyadic representation of $m$ is $(m+1)_2$ without is leftmost bit.
%%%%% PRELIMINARIES
%\paragraph{\emph{Preliminaries.}}
%
%
The intuition is at the basis of our definition
of an ``extractor'' function in $\POR$.


% It can be stated that,
% for any polynomial $p$, $n_1, \ldots, n_k\in \Nat$ and $\omega\in\Os$,
% there is $\underline p\in \POR^-\subseteq \POR$, %(or $\in \polyF$)
% such that
% $\underline p (\ovverline {n_1} \Nat, \ldots, \ovverline {n_k} \Nat, \omega) =
% \ovverline {p(n_1, \ldots, n_k)} \Nat$. The proof is in Corollary \ref{cor:polyinpor}.


% $|t(x,\omega)|=p(|x|)$.
% Then, there is also a $t \in \POR$ such that
% for any $\vec{x} \in \Ss$ and $\omega \in \Os$,
% $|t(\vec{x},\omega)|= p(|\vec{x}|)$.
%
%











First, we define a function $bin:\Ss\times \Os\longrightarrow \Ss$
such that, if $x$ has length $k$,
then for every $\omega\in \Os$,
$bin(x,\omega)$ is the binary encoding of $k$.
%\footnote{For
%readability's sake, we define functions in a semi-formal way.
%The formal definition of their representability in $\POR$
%can be found in Chapter \ref{chap:tech}~\ref{??}.}





\begin{defn}
Let us define an auxiliary function
$binsucc:\Ss\times \Os\longrightarrow \Ss$,
\begin{align*}
binsucc(\eepsilon,\omega) &:= {\one}; \\
binsucc(x\zero,\omega) &:= x\one|_{x\zero\zero}; \\
binsucc(x\one,\omega) &:= binsucc(x,
\omega)\zero|_{x\zero\zero}.
\end{align*}
Then, $bin:\Ss\times \Os \longrightarrow \Ss$ is
defined as:
\begin{align*}
bin(\eepsilon,\omega) &:= {\zero}; \\
bin(x\bool,\omega) &:= binsucc\big(bin(x,\omega),\omega\big)|_{x\bool}.
\end{align*}
\end{defn}
%
On top of the definition of the binary encoding of a number,
we define the dyadic encoding of it:
\begin{defn}
  We call $\mathit{dy}: \Ss \times \Os \longrightarrow \Ss$ the function in $\POR^-$ such that
  $\forall n \in \Nat, \omega \in \Os. \mathit{dy}(\ovverline n\Nat, \omega)$ is the dyadic encoding of $n$.
  Namely:
  \begin{align*}
    \mathit{dy}(x, \omega):= \lrs(bin(x, \omega), \omega)
  \end{align*}
  where $\lrs$ is the string manipulator defined in \ref{def:apprems} which removes
  the leftmost bit from a string, if it exists, otherwise it returns $\eepsilon$.
\end{defn}
%
In Chapter \ref{chap:tech} (Lemma \ref{lemma:dyadbij})
we prove that for any $\omega$,
the function $\mathit{dy}(\ovverline n\Nat, \omega)$
is a bijection between a a natural number $n$ and a string
--- its dyadic representation.
This result will be crucial to prove Lemma \ref{lemma:taskC1}, because it relates the set $\Bool^\Nat$ to $\Bool^\Ss$
throughout a bijection.
%
%
%
%
%
%
%
\noindent
We then define a function $e \in \POR$,
which takes a string and an oracle
as its input and returns a finite string obtained picking $|x|$ bytes from it,
choosing exactly the coordinates of $\omega$ corresponding to the dyadic encoding
of the first $|x|$ natural numbers.
%%% DEFN
\begin{defn}
Let $e :\Ss\times \Os \longrightarrow \Ss$ be defined as follows:
\begin{align*}
e(\eepsilon,\omega) &= \eepsilon; \\
%
e(x\bool,\omega) &= e(x, \omega)Q\big(\dy(x,\omega),\omega\big)|_{x\bool}.
\end{align*}
\end{defn}
%
%
\noindent

\begin{defn}
  We define $\sim_{\mathit{dy}}$ as the smallest relation in
   $\Bool^\Ss\times \Bool^\Nat$ such that:
   $$
   \eta \sim_\mathit{dy} \omega \leftrightarrow \forall n \in \Nat.
    \eta(n)= \omega (\mathit{dy}(\ovverline n \Nat, \omega)).
   $$
\end{defn}

\noindent
This relation has some good properties:

\begin{lemma}
  \label{lemma:funbij}
  It holds that:
  \begin{itemize}
    \item $\forall \eta \in \Bool^\Nat. \exists ! \omega \in \Bool^\Ss. \eta \sim_{\mathit{dy}} \omega$;
    \item $\forall \omega \in \Bool^\Ss. \exists ! \eta \in \Bool^\Nat. \eta \sim_{\mathit{dy}} \omega$.
  \end{itemize}
\end{lemma}
\begin{proof}
  The proofs of the two claims are very similar.
  For this reason, we will take in exam only the first claim.
  By the fact that $\mathit{dy}$ is a bijection with respect to its
  first argument and is constant with respect to the second,
  we obtain the existence of an $\omega$ which is in relation with $\eta$.
  Now suppose that there are $\omega_1, \omega_2$ both in relation with $\eta$
  being different. It holds then that $\exists \sigma \in\Ss$ such that
  $\omega_1(\sigma)\neq\omega_2(\sigma)$. Then, since $\mathit{dy}$ is in $\POR^-$,
  the value of its last argument does not affect the value of its output,
  moreover $\dy(\ovverline \cdot \Nat, \omega)$ it is a bijection so
  there is an $n\in \Nat$, such that $\dy(\ovverline n \Nat, \omega)=\sigma$,
  so we get $\eta(n)=\omega_1(\sigma)\neq \omega_2(\sigma)=\eta(n)$,
  which is a contradiction.
\end{proof}
\begin{cor}
  The relation $\sim_{\mathit{dy}}$ is a bijection.
\end{cor}

\begin{proof}
  Consequence of Lemma \ref{lemma:funbij}.
\end{proof}









%\newpage
\subsection{Concluding the Proof}\label{sec:conclsfp-por}



%%% COROLLARY
\lemmataskCone*
%%% PROOF
\begin{proof}
  From Corollary \ref{cor:sfptopor-}, we know that there is a function $f'\in \POR^-$,
  and a $p \in \POLY$ such that:
  \begin{equation}
  \forall x, y \in \Ss.\forall \eta.\forall \omega. y = \eta_{p(x)} \to  f(x, \eta) = f'(x, y, \omega).\tag{$*$}
\end{equation}
  So, by the fact that $\POR^- \subseteq \POR$, $f' \in \POR$, too.
  %
  % For this reason, the application of Lemma \ref{}, yields the following result:
  %
  % $$
  % \left(\forall 1 \le i \le p(|x|). \omega (\mathit{dyad}(i))={\eta}(i)\right) \to g(x, e(p(\mathit{size}(x, \omega), \omega), \omega), \omega) = f(x, \eta)
  % $$
  %
  Fixed an $\overline \eta \in \{\eta \in \Bool^\Nat \ | \ f(x, \eta)=y \}$,
  its image with respect to $\sim_{\mathit{dy}}$
  is in
  $$
  \{\omega \in \Os \ | \ f'(x, e(p'(\mathit{size}(x, \omega), \omega), \omega), \omega) =y\}.
  $$
  %
  Indeed, by Lemma \ref{lemma:auxsimdy}, it holds that
  $\overline \eta_{p(x)} = e(p(\mathit{size}(x, \omega), \omega)$, where $p'$ is the $\POR^-$
  function computing the polynomial $p$ and $\mathit{size}$ is the $\POR^-$
  function computing the encoding of the natural number which corresponds to the
  size of its first input. By $(*)$ we have the claim.
  It also holds that, fixed an $\overline \omega \in \{\omega \in \Os \ | \ f'(x, e(p'(\mathit{size}(x, \omega), \omega), \omega), \omega) =y\}$,
  then its pre-image with respect to $\sim_{\mathit{dy}}$ is in $\{\eta \in \Bool^\Nat \ | \ f(x, \eta)=y \}$.
  The proof is analogous to the one we showed above.
  Now, since $\sim_{\mathit{dy}}$ is a bijection between the two sets:
  $$
  \mu\big(\{\eta \in \Bool^\Nat \ | \ f(x, \eta)=y \}\big)
  = \mu\big(\{\omega \in \Os \ | \ f'(x, e(p(\mathit{size}(x, \omega), \omega), \omega), \omega) =y\}\big)
  $$
  which concludes the proof.
\end{proof}



\newpage
