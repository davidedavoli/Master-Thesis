% !TEX = short.tex
%!TeX spellcheck = en-US

\section{Auxiliary Results}
\label{sec:auxres}
%%%% SECTION SFP

\subsection{The Theory $\RS$}

\begin{remark}
  \label{rem:mufun}
  For each countable set $A$, the cylinder measure $\mu$ is a function.
\end{remark}
\begin{proof}
  Assume $X \subseteq \{\zero, \one\}^A$, and that:
  \begin{align*}
  X&=\{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K_1} \in H_1\}\\
  X&=\{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K_2} \in H_2\},
\end{align*}
we proceed by cases on the identity of the $K_i$ and $H_i$ for $i \in\{ 1,2\}$.
\begin{itemize}
  \item If the $K_i$s and the $H_i$s are identical, the conclusion is trivial.
  \item  Suppose $K_1=K_2$, while $H_1 \neq H_2$. This wound entail
  $X \neq X$, which is absurd.
  \item Suppose $K_1\neq K_2$, while $H_1 = H_2$. This is absurd because
  $H_i \subseteq \{\zero, \one\}^{K_i}$.
  \item Finally, we proceed by double induction on the elements
  of $K_1\setminus K_2$ and $ K_2\setminus K_1$. If such value is $0$,
  we get the claim, otherwise, suppose that there are $n+1$ one such elements.
  Without loss of generality, call that element $k$ and assume it in $K_1$.
  Let $K_2' = K_2 \cup \{k\}$ and
  $$
  H_2'=\{w \in \{\zero, \one\}^{K_2'}\, |\,  w|_{K_2} \in H\}.
  $$
  It holds that:
  $$
  \frac{|H_2'|}{2^{|K_2|}} = \frac{2\cdot |H_2|}{2^{|K_2+1|}}=
  \frac{2\cdot |H_2|}{2\cdot2^{|K_2|}}
  $$
  which proves the claim applying the IH.
\end{itemize}
\end{proof}



\begin{remark}[Cylinder measure]
  \label{rem:mumeas}
  For each countable set $A$, $\mu$ is a measure function.
\end{remark}
\begin{proof}
  First, we show that $\mu$ is defined on all the elements of the field on $\{\zero, \one\}^A$.
  \begin{itemize}
    \item If $X$ is a cylinder, then the conclusion is trivial.
    \item If such element is the union of two elements of the field $X_1$ and $X_2$,
    then $\mu$ is defined on them, so they can be expressed as cylinders.
    So they are two elements defined as
    \begin{align*}
      X_1=\{\omega \in \{\zero, \one\}^A\, |\, \omega|_K \in H\}\\
      X_2=\{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K'} \in H'\}.
    \end{align*}
    Thus we get that:
    $$
    X = X_1 \cup X_2 = \{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K \cup K'} \in H''\},
    $$
    with
    $$
    H'':=\{w \in \{\zero, \one\}^{K\cup K'}\, |\, w|_K \in H \lor w|_{K'} \in H'\}.
    $$
    So, $\mu$ is defined on $X$.
    \item Finally, if $X$ is obtained by complementation, we get that:
    $$
    X = \Bool^A \setminus X'= \{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K}\not  \in H'\} = \{\omega \in \{\zero, \one\}^A\, |\, \omega|_{K} \in \Bool^K \setminus H'\},
    $$
    which is itself a cylinder, so $\mu$ is defined on it.
  \end{itemize}
  Now we show that $\mu$ is a probability measure over the field generated by
  $\{\zero, \one\}^A$.
  \begin{itemize}
    \item It is trivial to see that $0 \le \mu(X)\le 1$ for every cylinder $X$.
    \item Similarly, it is easily possible to verify that $\mu(\emptyset)=0$
    and that $\mu (\{\zero, \one\}^A)=1$.
    \item Finally, suppose that $A_1, A_2,\ldots$ is a sequence of pairwise
    disjoint sets such that
    $A=\bigcup_{i = 1}^\infty A_i$ is a cylinder, then $A$ can be expressed as follows:
    $$
    A = \{\omega \in \{\zero, \one\}^A | \omega|_K \in \bigcup_{i=1}^\infty H_i\},
    $$
    with $H= \bigcup_{i=1}^\infty H_i$ finite. Moreover,
    all the $H_i$s are finite and pairwise disjoint.
    So
    $$
    \mu(A) = \frac{|\bigcup_{i=1}^\infty H_i|}{2^{|K|}}=\frac{\sum_{i=1}^\infty|H_i|}{2^{|K|}}=\sum_{i=1}^\infty\frac{|H_i|}{2^{|K|}}=\sum_{i=1}^\infty\mu(H_i).
    $$
  \end{itemize}
  Finally, applying \cite[Theorem 3.1]{Billingsley}, we get the claim.
\end{proof}

\subsection{The Class $\SFP$}
\label{app:c1}

\begin{proof}[Proof of Proposition~\ref{prop}]
The proof is by induction on $n$.

$n=0$. Then, $\m{\triangleright^n_M}$ is the identity function.

$n+1$. By IH $\m{\triangleright^n_M}$ is a function.
Since $\vdash_{\m{\delta}}$ is a function,
$\m{\triangleright^{n+1}_M} =
\m{\triangleright^n_M} \circ \vdash_{\m{\delta}}$
is a function too.
\end{proof}


































%%%%% PROOF 2
%\subsection{Section~\ref{sec:SFPtoPOR}}

%\begin{proof}[Proof of Lemma~\ref{lemma:SFPchar}]
%$\Rightarrow$ Trivial.  Let us use the transition function of the  underlying machine $M$ as $\delta$ and $q$ as its initial state.
%
%Such objects exist due to  Definition~\ref{df:streamMachine},~\ref{df:PSTM},~\ref{df:SFP}.
%
%The polynomial $p$ is the time-bound of $M$, which exists according to Definition~\ref{df:PSTM}.

%$\Leftarrow$ The characterization ensures that the $\overline{\triangleright}^\delta_n$ is stationary after a polynomial number of steps.
%
%So, we can build a $\delta'$ function which is obtained  from $\delta$ pruning the self-loops between states. So, $\delta'$ and $q$ allows us to synthesize a STM $M'$, which is an $\SFP$-machine  by  Definition~\ref{df:streamMachine},~\ref{df:PSTM},~\ref{df:SFP}.
%\end{proof}







% \paragraph{\emph{Characterizing $\SFP$}}
%
% \begin{proof}[Proof of Lemma~\ref{lemma:transitionFunc}]
%   By induction on $n$, leveraging the fact that even $\vdash'_\delta$ is a function, which itself is a consequence of the fact thhat $\delta$ is a function.\end{proof}
%
%
%
%
% \begin{proof}[Proof of Lemma~\ref{lemma:char}]
% {If $f\in \fcob$, then
% there is a poytime TM $M$, which computes it.
% %
% It suffices to take the define $\delta$
% as the machine's transition function and
% $p$ as the its time-bound.
% %
% By definition, this if the $M$ halts at step
% $k<p(|x|)$, then $\overline{\stmreach}$ is constant
% for $k>k'$. This proves the claim.
% %
% Suppose that there are such $\delta$ and $p$,
% then the canonical TM which uses $\delta$
% as transition function computes $f$}
% \end{proof}









































































%\subsection{Section~\ref{sec:H}}







































%\newpage
\subsection{From $\polyF$ to $\POR^-$}
\label{app:secg}











\begin{lemma}
  \label{lemma:simcorr}
  If $\gamma$ is a function $\Ss \longrightarrow \Ss$ such that $|\gamma|=n$,
   define $x_\gamma = \listenc {\listenc {x_1, y_1} 2, \ldots,
  \listenc {x_n, y_n} 2} n$,  then
  $\simulate(x, x_\gamma, \omega)=\gamma(x)$,
  otherwise $\simulate(x, x_\gamma, \omega)=\eepsilon$.
\end{lemma}
\begin{proof}
  Let $\omega \in \Os$ any oracle.
  Suppose $x'$ is in $\gamma$'s domain. It means that there is a tuple
  $t=\listenc{x', \overline y} 2$ among the elements of $x_\gamma$, so there is
  $k \in \Nat$ such that $t=\pi_k(x_\gamma, \omega)$.
  Thus, we can prove that if the third argument of $\simulate'$
  is the number of elements in $t$, then
  $\forall k\le m < \pi_0 (t, \omega). \simulate'(x_\gamma, x,
  \ovverline m \Nat, \omega)=\overline y$; this result can be established by induction
  on $m$. Leveraging the fact that $\gamma$ is a function, so in its graph there
  cannot be two pairs with the same first projection.
  Then, the correctness of $\simulate$ comes as consequence because it is
  an instance of $\simulate'$ with a value which is greater or equal to any
  possible value of $k$, namely the number of pairs in $x_\gamma$.
  Now suppose that $x'$ is not in $\gamma$'s domain,
  then there is not a $k$ such that
  $\pi_k(x_\gamma)=\listenc{x', \overline y} 2$, so $\simulate'$ returns
  $\eepsilon$.
\end{proof}

\begin{defn}[Apply]
The function $\apply(\cdot,\cdot,\omega)\in \POR^-$
is defined as follows:
$$
\apply(x_\delta,x_c,\omega) := \mathtt{if}\big(x_c, g(x_c,x_\delta, \omega),
\lnot(eq(\xi(x_c,x_\delta,\omega),\eepsilon,\omega),\omega),
\omega\big),
$$
where:
\begin{align*}
g(x,y,\omega) &= \mathtt{if}\big(f_{1}(x,y, \omega), f_{2}(x,y, \omega),
eq(\xi(x,y,\omega),\zero,\omega),
\omega\big) \\
%
%
\\
f_{1}(x,y, \omega) &= \langle \chi(rrl(\pi_1(x,\omega),\omega),
\omega), \pi_3(\xi(x,y,\omega),\omega), \\
%
& \ \ \ lal(lal(lrl(\pi_3(x,\omega),\omega),
\pi_1(\xi(x,y,\omega)),\omega), rel(\pi_1(x,\omega),\omega),\omega) \\
%
& \ \ \ \lrl (\pi_4(x,\omega),\omega)\rangle_\Ll \\
%
f_{2}(x,y, \omega) &= \langle ral(rrl(\pi_1(x,\omega),\omega),
\pi_1(\xi(x,y,\omega),\omega),\omega),
\pi_3(\xi(x,y,\omega),\omega), \\
%
& \ \ \ \chi(lrl(\pi_3(x,\omega),\omega),\omega),
\lrl (\pi_4(x,\omega),\omega)\rangle_\Ll \\
%
\\
\chi(x,\omega) &= \mathtt{if}\big(\underline \circledast_\Tt,
x, eq(\pi_0(x,\omega), \underline{0}_\Nat,
\omega),\omega\big) \\
%
\xi(x,y,\omega) &= sim\big(y,\langle \pi_2(x,\omega),
\lel(\chi(\pi_3(x,\omega),\omega),\omega),
\lel(\chi(\pi_4(x, \omega), \omega), \omega)\big).
\end{align*}
\end{defn}


\applycorr*
\begin{proof}
  It should not be too much of a problem to see
  that the function $\chi$ return a tape which contains an instance of the
  blank character if and only if the tape passed as argument is empty,
  otherwise it returns its argument.
  %
  Thanks to this observation, we prove that $\xi$ is defined as the
  invoking of $\simulate$ on:
  \begin{enumerate}
    \item The machine's transition function $\delta$;
    \item The tuple containing:
    \begin{enumerate}
      \item The current state $\pi_2(x_c, \omega)$;
      \item The current character $\lel(\chi(\pi_3(x_c, \omega), \omega), \omega)$;
      \item The first character on the oracle tape, i.e.
      the \emph{random} bit $\lel(\chi(\pi_3(x_c, \omega), \omega), \omega)$.
    \end{enumerate}
  \end{enumerate}
  This call to the $\simulate$ function returns either the encoding of the image of this inputs through $\delta$ (if defined), or $\eepsilon$ otherwise, as a consequence of Lemma
  \ref{lemma:simcorr}.
  %
  Suppose that the result of $\xi$ is $\eepsilon$, then the claim is
  trivially true, since the function returns exactly its input, as required by the claim.
  %
  Otherwise, suppose that $\xi$ returns a value different from $\eepsilon$.
  It means that $\delta$ is defined on its input, so, the guard of the inner
  $\mathtt{if}$ expression checks whether the result describes a right or
  left movement of the head and, depending on the response, behaves
  differently. Observe that the constant $L$ is represented by $\zero$
  as stated in Definition \ref{def:canencs}.
  %
   We will show only the case in which the head moves right, for the left
   movement the proof is analogous. The configuration is made up as follows:
   \begin{enumerate}
     \item The left portion of the tape tape $\ral(\rrl(\pi_1(x_c,\omega),\omega),
    \pi_1(\chi(x_c, x_\delta, \omega),\omega))$
     is obtained removing the current character by means of
     $\rrl(\pi_1(x_c,\omega),\omega)$, appending
     the character which is written by the head
     $\pi_1(\chi(x_c, x_\delta, \omega),\omega)$ by means of $\ral$.
     \item The current state is obtained projecting
     the third element of $\chi$.
     \item The right portion of the work tape tape loses its leftmost element, becoming
     $\ovverline \circledast \Tt$ if empty, as described by
     $\chi(\lrl(\pi_3(x_c,\omega),\omega), \omega)$.
     \item The second tape loses its leftmost character.
   \end{enumerate}
   The function $\chi$ prevents to obtain empty list as encodings of a tape,
   as required by Definition \ref{def:canencs}.
  \end{proof}







\saPOR*

\begin{proof}
  \label{proof:saPOR}
Given $f\in \POR^-$ and $t\in \mathcal{L}_{\mathbb{PW}}$,
let $sa_{f,t}$ be defined as follows:
\begin{align*}
sa_{f,t}' (x,\eepsilon, \vec{z}, \omega) &:= x \\
sa_{f,t}' (x,y\bool, \vec{z}, \omega) &:= f\big(sa_{f,t}'(x,y,\omega),
\vec{z},\omega\big)|_{t} \\
\\
sa_{f,t}(x,y,\vec{z},\omega) &:= sa_{f,t}'(x, rrs(y,\omega),\vec{z},\omega).
\end{align*}
{The function $sa$
is correct as $\underline{n}_\Nat$
has size $n+1$.}
%
We prove that if $|y| = n$,
then $sa_{f,t}'(x,y,\vec{z},\omega)=
f(f(f(\vec{x},\vec{z},\omega), \vec{z},\omega)\dots)$,
nested $n$ times,
by induction on $n$.
\begin{itemize}
  \item If $n=0$, $sa_{f,t}$ reduces to $sa_{f,t}'$ with argument $\epsilon$,
  so the result is $x$.
\item $n+1.$ By applying IH and the definition of $sa_{f,t}'$. \\
\end{itemize}

The correctness of $\sa$ comes as a consequence of the correctness
of the function $\rrs$ (which removes the rightmost digit of a string)
and of the definition of $sa$.


\end{proof}

\applysize*
\begin{proof}
  \label{proof:applysize}
  At each step, the function $\apply$ manipulates three values:
  \begin{itemize}
    \item The portion of the tape on the left of the head;
    \item The portion of the tape on the right of the head;
    \item The current state.
  \end{itemize}
  %
  The manipulation of the tapes is done through shifting of characters and
  rewriting. An ordinary shifting operation does not change
  the overall size of the encoded configuration, while the rewriting can cause such phenomenon,
  due to the different sizes of the encoded characters, but fixed a machine,
  the maximum size of its characters is fixed. Say that value $k_1 \in \Nat$.
  Replacing a character on the encoded tape with it takes less than $2\cdot k_1$ bits.
  Even if a tape contains an infinite sequence of $\circledast$ and the machine
  moves in that direction, the overall result is the appending of a character on
  the other portion of the tape this takes exactly $2\cdot k_1$ bits, plus
  $2$ additional bits to store the new size of the portion of the tape which
  grows by one.
  %
  Then, we must take in account the difference in size due to the new state,
  but since the numbers of state in a machine is fixed, there is a constant $k_2$
  which bounds the size of any state, so rewriting a state takes less than
  $2\cdot k_2$ additional bits.
  %
  Finally, we must take in account the representation of the second tape:
  at each step, we strip off a cell from its representation since the head
  moves always on the right, so it causes no term growth.
  %
  The value of $k$ we are looking for is $2 \cdot(1+k_1+k_2)$.

\end{proof}


























































%\newpage
\begin{lemma}
  \label{lemma:dectape}
  The $\POR$ function $\dectape :
  \Ss \longrightarrow \Ss$ is
  such that if $\ovverline \cdot \Tt$ is the encoding for tapes
  proposed in Definition \ref{def:canencs}, then it holds that
  $\forall \sigma \in \{\zero, \one, \circledast\}^*, \omega.
   f(\ovverline \sigma \Tt, \omega)=
  \tau$ and $\tau$ is the longest suffix of $\sigma$ without $\circledast$.
\end{lemma}
% \begin{proof}
%   Take the function $\mathit{dectape}$ defined below:
%   \begin{align*}
%     \rho(t, x, \omega)&:= \pi(t, \mathit{diff}(\pi_0(t, \omega),
%     x, \omega), \omega)\\
%     \mathit{dectape}'(t, \eepsilon, \omega) &:= \eepsilon\\
%     \mathit{dectape}'(t, x\bbool, \omega) &:= \mathtt{if}(
%     \mathit{dectape}'(t, x, \omega)\rho(t, x\bbool, \omega),
%     \eepsilon, \lnot \eq(\rho(t, x\bbool, \omega),
%     \one\one\one, \omega), \omega)\\
%     \mathit{dectape}(t, \omega) &:= \mathit{dectape}'(t,
%     \rrs(\pi_0(t, \omega), \omega), \omega)
%   \end{align*}
%   Before proceeding with the correctness of $\mathit{dectape}$, we must prove
%   that, if $t$ is the encoding of a tape through $\ovverline \cdot \Tapes$, $x=\ovverline n\Nat$ and $n \le |t|$, $\rho(t, x, \omega)$ returns the $n$-th
%   projection of $t$ from the right. This is a consequence of the correctness
%   of the functions used in the definition of $\rho$, which has already been shown.
%   %
%   Before, we ought proof that $\mathit{dectape}'$ is a generalization of dectape,
%   for which $x=\ovverline n\Nat \to \ovverline \sigma \Tapes = t \to
%   \mathit{dectape}'(t, x, \omega)$ is the longest substring whithout
%   $\circledast$ of $\sigma$ which ends in
%   the $n$-th character of $\sigma$ from the left.
%   The proof of the main claim is by induction on $n$:
%   \begin{itemize}
%     \item[$0$] According to what we proved above about $\rho$, and the fact the
%     function checks the rightmost character of the $\sigma$'s encoding. Moreover,
%     the encoding of any encoded $\sigma \in \Sigmab^*$ contains at least one
%     charater. if this characteris $\circledast$ its encoding
%     is $\one\one\one$, so the condition on the $\mathit{if}$'s guard
%     is verified and the whole expression reduces to $\eepsilon$, otherwise
%     the function returns the decoding of the remaining part (which reduces
%     to $\eepsilon$) and the decoded value of the character in exam.
%     \item[$n+1$] The claim follows from the IH on the
%     recursive call, ad the condideration above regarding the value of the
%     projected character.
%   \end{itemize}
% The main claim can be proved by joining the consideration above and the fact
% that the definition of $\mathit{decode}$ is defined as an instance of
% $\mathit{decode}$ with $x$ equal to the size of $\sigma$, so the substring
% returned by $\mathit{decode}'$ is actually a suffix.
% \end{proof}
\begin{proof}[Proof of Lemma~\ref{lemma:dectape}]
Let us consider the function $\dectape(x,\omega)$, described
in Definition \ref{def:dectape}.
If $x= \underline{\sigma}_\Tt$ is the encoding of a tape $\sigma \in \Sigmab^*$,
$y=\underline{n}_\Nat$ and $n \leq |\sigma|$,
so $\rho(x,y,\omega)$ returns the $n$-th projection
of $\sigma$ from the right.
%
This is a consequence of the correctness of the function
used in the definition of $\rho$,
which we have already discussed.
%
In order to show the correctness of $\dectape$,
we prove that $\dectape'$
is a generalization of $\dectape$,
for which if $y=\underline{n}_\Nat$ with $n>0$,
and  $\underline{\sigma}_\Tt = x$, then
$dectape'(x,y,\omega)$ is the longest subfix
without $\blank$, of $\sigma$'s $n$-th prefix.
%
The proof is by induction on $n$.
\begin{itemize}
  \item Case $0$. In this claim we have with the condition $n>0$.
  \item Case $n+1$. According to the IH, the recursive call returns the longest
  suffix of the $n$-th prefix of the string. Form the consideration above, thus
  In this case, intuitively, $\rho$ checks the $n+1$-th character from the left
  of the encoding for $\sigma=\sigma'c$.
  %
  If the character $c$ is $\blank$, its encoding will be $\one\one\one$,
  so the condition in the guard of $\mathtt{if}$ is verified
  and the whole expression reduces to $\eepsilon$, which is indeed
  the longest suffix of $\sigma' \blank$ without $\blank$.
  %
  Otherwise, the function returns the decoding of the
  $\mathit{\dectape'}(x,y,\omega) = \tau$, which is the longest suffix of $\sigma'$
  without $\blank$, thus the function returns $\tau c$.
  This string is free from $\blank$ as a consequence of the IH and is also the longest
  suffix of $\sigma$ with this property: otherwise, $\tau$ would not be the
  longest suffix of $\sigma'$ free from $\blank$, contradicting the IH.
  %
\end{itemize}
\noindent
We conclude the proof by summing the consideration above
and the fact that the definition of $\dectape$
is defined as an instance of $\dectape'$
with $x$ equal to the size of $\sigma$.
So, the substring returned by $\dectape$
is actually a suffix.
\end{proof}












































\subsection{Extractor Function in $\POR$}



\begin{lemma}
  \label{lemma:dyadbij}
  The function $\mathit{dy}(\ovverline n \Nat, \omega)$ is bijective with respect to its first argument.
\end{lemma}
\begin{proof}
  By the definition of the function, we know that it is in $\POR^-$, so
  the function is constant with respect to its second parameter. Moreover,
  it is clearly an injection because different numbers have different binary encodings
  and $\forall n>0 \in \Nat.\forall \omega \in \Os. \mathit{bin}(n,\omega)$ has $\one$
  as leftmost bit
  (it can be shown by induction on $n$, leveraging the definition of $\mathit{bin}$).


  So if we take two distinct binary encodings of natural numbers $n, m$ and call them $\one\sigma$ and $\one\tau$.
  It must hold that $\sigma \neq \tau$, otherwise we would have $n=m$.

  So we just need to show that it is surjective. We know that $\mathit{dy}$
  is computed removing a bit which is always $\one$.
  This entails that taken a string $\sigma \in \Ss$,
  it is the image of the natural number $n$ such that
  the binary encoding of $n+1$ is $\one \sigma$. This number always exist.
\end{proof}

\begin{lemma}[Correctness of $e$]
  \label{lemma:corrofe}
  $\forall i \in \Nat.\forall j \le i. \forall \omega \in \Bool^\Ss. e(\ovverline i \Nat, \omega)(j) = \omega(\mathit{dy}(\ovverline j\Nat, \omega))$
  and the length of $e(\ovverline i \Nat, \omega)$ is exactly $i+1$.
\end{lemma}
\begin{proof}
  By induction on $i$:
  \begin{itemize}
    \item[0] For the first claim we have that:
    $$
    e(\one, \omega)(0)=\eepsilon Q\big(\dy(\one,\omega),\omega\big)= \omega(\dy(\one,\omega)).
    $$
    While, the second claim is trivial.
    \item[i+1] By the IH on the second claim, we get that for $j=i+1$, the
    $j$-th element of $e(\ovverline {i+1} \Nat, \omega)$ is exactly
    $Q\big(\dy(\ovverline {i+1}\Nat,\omega), \omega \big)$, which is equal to
    $\omega(\dy(\ovverline {i+1}\Nat,\omega))$. For smaller values of $j$,
    the first claim is a consequence of the definition of $e$ and the IH.
    The second claim is trivial.
  \end{itemize}\end{proof}


\begin{lemma}
  \label{lemma:auxsimdy}
  $$
  \eta \sim_{\mathit{dy}} \omega \to \forall n \in \Nat. \eta_n = e(\ovverline n \Nat, \omega).
  $$
\end{lemma}
\begin{proof}
  By contraposition: suppose that the consequence does not hold:
  $$
  \eta_n \neq e(\ovverline n \Nat, \omega).
  $$
  As a consequence of the correctness of $e$ (Lemma \ref{lemma:corrofe}),
  this means that there is an $i \in \Nat$ such that
  $\eta(i)\neq\omega(\mathit{dy}(\ovverline i\Nat, \omega))$,
  which is a contradiction.
\end{proof}
