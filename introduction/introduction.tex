%!TeX spellcheck = en-US
At a broad level, Logic relies on proofs, which are assessments of an entailment between some premises and a consequence. Proofs are, ultimately, syntactical objects relating some formul\ae{} --- the \emph{premises} --- to another formula --- called \emph{consequence} --- according to some system of rules, called proof system.

Similarly, Computer Science is founded on the notion of program. Again, programs are syntactical objects, relating some input data with an output. Even programs, for being accepted by the compiler, must follow a system of rules called type system.

The correspondence between programs and proofs --- and at the higher level the correspondence between types and formul\ae{} --- grounds the so-called Curry-Howard isomorphism \cite{curry34, Howard}. This relation brings fruitful contributions to both the fields of Computer Science and logic. In Computer Science, for example, it is possible to shape computational formalisms upon well-behaved logics. These formalisms, for instance, are particularly suited for program analysis because of their solid logical properties. On the side of Logic, this correspondence makes it possible to represent proofs by means of computer programs, reducing the act of deducing a proof to the act of coding a well typed function.

Another consequence of this correspondence is the possibility to approach computational complexity by means of peculiar logical theories, called bounded srithmetics.
%
These are basically first-order logical theories generated by four elements: a logical language $\mathcal L$, its semantics $\llbracket \cdot\rrbracket$, a set of axioms $A$ and a proof system $\vdash$, which are capable to capture well known classes of program --- often complexity classes --- relating them with collections of foruml\ae{}.
%
This relation is grounded on the notion of provability: each derivation rule has a well known corresponding computation step. Thus, a program --- i.e. a sequence of computational steps --- can be represented by means of a proof, which is a sequence of deduction rules. For this reason, within a bounded arithmetics it si possible to identify certain \emph{provable formul\ae{}} which correspond to computable functions.
%
Tailoring this theory --- or, more often, its language $\mathcal L$ and the set of its axioms $A$ --- it is possible to identify, within a bounded arithmetic, classes of formul\ae{} which correspond to well-known complexity classes.

In his PhD thesis \cite{Buss86}, S. Buss managed to develop a bounded arithmetic which characterizes the complexity class $\FP$. Precisely, Buss proved that every polynomial-time computable function corresponds to a function which is $\Sigma^b_1$-definable in the corresponding bounded theory $S^1_2$ \cite{Buss86}. This result is very insightful, but no similar works have been proposed in the realm of probabilistic computation, yet.

In contrast with deterministic computation, the probabilistic framework allows the computational models --- canonically \emph{Probabilistic Turing Machine} --- to take purely random choices in each step of its computation. Thus, in this setting, reduction becomes a stochastic process, and the semantics of a program can no more be reduced to a function mapping inputs to outputs. Instead, it becomes a function which associates to any input a distribution of probability over its possible outputs.

The probabilistic framework has some relevant advantages with respect to the deterministic one: in particular, random choices allow to approximate solutions to problems with smallest average case time consumption and arbitrarily low error. This is evident if we examine the complexity class $\BPP$, which contains all the decision problems having a probabilistic poly-time algorithm solving them with arbitrarily low error, and thus is intended to capture \emph{feasibility} in probabilistic computation. Indeed, there are problems which are in $\BPP$, but which are yet not known to be in $\mathbf P$. For instance, the probabilistic algorithm for solving the Polynomial Identity Test is not known to have any solution in $\mathbf P$, but it is known to have one in $\BPP$.
%
As for $\mathbf {NP}$, there are open problems concerning $\mathbf {BPP}$ and $\mathbf P$. The most important is probably $\mathbf P = \BPP$, indeed many problems in $\BPP$ have been recently discovered being in $\mathbf P$ such as, for example, the Primality Test.

Since November 2021 I am involved in a joint research project with
Prof. Ugo Dal Lago, Dr.
Paolo Pistone and Dr. Melissa Antonelli
from University of Bologna
and with Prof. Isabel Oitavem from NOVA University of Lisbon, Portugal.
%
%
The contribution of our work consists precisely in extending Buss' work to the study of probabilistic complexity classes.
The basic idea is to generalize $S^1_2$'s language and semantics to a quantitative setting. Concretely, the first step consists in relating bounded formul\ae{} with some effective model for probabilistic computation.

For this purpose, we introduced three novel classes of functions and prove them equivalent:

\begin{enumerate}
\item The class of
\emph{polynomial-time oracle recursive functions} ($\POR$),
which is a Cobham style function algebra \cite{Cobham1965}, with the
capability to query an \emph{oracle-function}
$\omega: \{\zero, \one\}^* \longrightarrow \{\zero, \one\}$ to
\emph{possibly random} bits during the evaluation.

\item The class of functions which are
$\Sigma^b_1$-representable in $\RS$,
where $\RS$ are di axioms of our \emph{randomized bounded theory}.
%
This theory is expressed in a  ``probabilistic
word language'', %$\mathcal{L}_{\mathbb{W}}$,
%the intended interpretation of which is the class
%of $\mathbf{0}$-$\mathbf{1}$ strings.
%
which is a canonical first-order
%$\mathbf{0}$-$\mathbf{1}$
word language with equality inspired from~\cite{FerreiraOitavem}, augmented
by a special unary ``probabilistic'' predicate $\Flip(\cdot)$~\cite{ADLP21}.
%
%Inspired by $\MQPA$, we also introduce  a quantitative semantics such that  formul\ae{} in $\mathcal{L}_{\mathbb{W}}$ are associated to (measurable) sets of strings.
%
%Then, $\RS$ is defined as a \emph{bounded} theory very close to Buss's $S^1_2$~\cite{Buss} and Ferreira's $\Sigma^b_1$-NIA~\cite{Ferreira88,Ferreira90}.
%
%We also slightly modify the standard notion of $\Sigma^b_1$-representability so to deal with our theory, as defined in a probabilistic word language, and our class $\POR$ of oracle functions over strings (and not over natural numbers). (It is in this context the quantitative interpretation of $\mathcal{L}_{\mathbb{W}}$ becomes crucial.)



\item The class of \emph{$\SFP$-functions},
which is the class of functions computable by
%$\SFP$-machines, i.e.
polynomial-time
Stream Machines.
%
These are almost ordinary $k+1$-taped
Turing machines; the only difference is that
one of their tapes,
called the \emph{oracle tape},
is used as a left-to-right read-only tape
and contains an infinite sequence of random bits.
%
These machines differ from standard probabilistic Turing
machines~\cite{Santos69,Gill77},
as their access to randomness is close to
that of $\POR$'s functions: their computation depends on
a function $\eta: \Nat \longrightarrow \{\zero, \one\}$ which
describes the configuration of the \emph{oracle tape}.
%

\end{enumerate}



%
%
%
%
%
%
%
%Then, we prove that  functions in $\POR$ are precisely those in $\SFP$ in two main steps:
%We prove that each poly-time oracle function are precisely the $\Sigma^b_1$-representable ones.
%We generalize Cobham's result showing that  functions in $\POR$ are precisely those in $\SFP$.
%

Our main result consists in proving
that the class of functions which are
$\Sigma^b_1$-representable in $\RS$
is precisely the class of polynomial-time computable
ones which, in turn, coincides with the
class of $\SFP$-functions.
%
%In this way, we manage to represent in our logical system the desired  probabilistic computational model and to deal with formula expressing.
%
%Together with the notion of measure-quantifiers, this allows us to switch to a probabilistic model of computation to provide (semantic) characterizations of probabilistic classes.
%
%For example, one can imagine to characterize a class of probabilistic functions, for example the one corresponding to problems in $\BPP$~\cite{AroraBarak}, using (a special, simple kind of) formul\ae{} of $\MQPA$ to generalize (ii) below with a condition satisfied with respect the appropriate bound, in the case of $\BPP$ as $\BOX^{2/3}A(x,f(x))$.
%
Then, starting from this equivalence,
it seems possible to characterize probabilistic classes,
such as $\BPP$ or $\ZPP$,
using formul\ae{} of the bounded theory $\RS$
together with non-standard quantifiers.
%
For instance, functions corresponding to problems
in $\BPP$ could be characterized leveraging a
measure-sensitive quantifier $\BOX$ in the style of $\MQPA$, \cite{ADLP,ADLP21}.
%

In this work, I will describe the main advances we have made to this end,
primarily focusing on my personal contributions which
are the reductions from $\POR$ to $\SFP$,
and vice-versa, the equivalence between $\SFP$ and $\PPT$,
A logical characterization of some probabilistic complexity classes.

The thesis is structured as follows: in Chapter \ref{chap:preliminaries},
I recall describe the scientific context of this work,
recalling some basic probability notions together, together with Buss'
Bounded Arithmetic, then in Chapter \ref{chap:RBA}, the $\RS$ is defined
together with the $\POR$ function algebra and a representability result between
the two classes. Later, I will focus on my personal contributions to this research:
in Chapter \ref{chap:sfptopor}, I investigate the equivalence between $\POR$ and
the class of functions which are computable in polynomial time by a Probabilistic
Turing Machine, i.e. $\PPT$. Thus, I generalize the main result of Chapter \ref{chap:RBA}
Showing that the $\RS$ representable functions are exactly the $\PPT$ ones.
In Chapter \ref{chap:cobham}, I show that the equivalence between $\POR$ and
$\PPT$ has, as corollary, the equivalence between a Cobham-style function algebra ---
thereby introduced and called $\polyF$ --- and the complexity class $\FP$. Finally, Chapter
\ref{chap:characterization} contains the characterizations of some standard
probabilistic complexity classes by means of a semantical condition expressed
in a word language $\Lmq$ inspired by $\Lpw$ and $\MQPA$.
